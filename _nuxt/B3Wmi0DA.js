import{S as d,I as D}from"./ClLpnmyR.js";import{I as Q}from"./OlYXjGCK.js";import{S as J}from"./CtlMGvom.js";import{O as X}from"./BkRx7U8b.js";class x{id;_locked=!1;storage;name;_data=[];constructor(e){this.id=e.id,this._locked=e.locked||this._locked,this.storage=e.storage,this.name=e.name}get locked(){return this._locked}get data(){return this._data}set data(e){this._data=e}async mount(...e){return this}async unmount(...e){return this}getItem(e){throw new Error("not implemented")}setItem(e,t){throw new Error("not implemented")}async load(){if(!this.storage)throw new Error("no storage");return this._data}async save(e){if(!this.storage)throw new Error("no storage");return this._data=e||this._data,this._data}}class M{isLogged(){throw new Error("Method not implemented.")}getItem(e){throw new Error("Method not implemented.")}setItem(e,t){throw new Error("Method not implemented.")}removeItem(e){throw new Error("Method not implemented.")}clear(){throw new Error("Method not implemented.")}}class ee extends M{#e=new Map;isLogged(){return!0}getItem(e){return this.#e.get(e)||null}setItem(e,t){this.#e.set(e,t)}removeItem(e){this.#e.delete(e)}clear(){this.#e.clear()}}class b extends x{constructor(e){super({...e,storage:new ee})}}class te extends M{isLogged(){return!0}getItem(e){return localStorage.getItem(e)}setItem(e,t){localStorage.setItem(e,JSON.stringify(t))}removeItem(e){localStorage.removeItem(e)}clear(){localStorage.clear()}}class G extends x{async mount(){let e;if(this.storage instanceof x){const t=this.storage;try{if(e=t.getItem(this.name),e){if(e=JSON.parse(e),!e||!(e instanceof Object))throw new Error("json invalid")}else throw new Error("json invalid")}catch(r){console.error(r),e={}}this.storage.setItem(this.name,e)}return this}async load(){return this.storage&&this.storage instanceof M&&(this.data=JSON.parse(this.storage.getItem(this.name)||"[]")),this.data}async save(e){return this.storage&&this.storage instanceof M&&(this.data=e||this.data,this.storage.setItem(this.name,this.data)),this.data}}class se extends G{constructor(e){super({...e,storage:new te})}}class re extends M{isLogged(){return!0}getItem(e){return sessionStorage.getItem(e)}setItem(e,t){sessionStorage.setItem(e,JSON.stringify(t))}removeItem(e){sessionStorage.removeItem(e)}clear(){sessionStorage.clear()}}class ae extends G{constructor(e){super({...e,storage:new re})}}class ie extends x{constructor(e){super({...e})}isLogged(){throw new Error("Not implemented")}}var p=(s=>(s[s.NONE=0]="NONE",s[s.AUTO=1]="AUTO",s[s.TEMP=3]="TEMP",s[s.LOCAL=4]="LOCAL",s[s.SESSION=5]="SESSION",s[s.CLOUD=6]="CLOUD",s))(p||{});function ne(s){switch(s){case 3:return b;case 4:return se;case 5:return ae;case 6:return ie;default:return b}}function Re(s){return typeof s=="string"&&R(s.trim())}const oe=['"',"'"];function Le(s,e='"'){return R(s)?s:(s=s.replace(/"/g,'\\"'),`${e}${s}${e}`)}function Fe(s){return s.length===2&&s[0]===s[s.length-1]&&R(s)}function R(s){return s[0]===s[s.length-1]&&oe.includes(s[0])}function Ne(s){if(typeof s=="string"){const e=s.trim();if(R(e))return e.slice(1,s.length-1).replace(/\\"/g,'"')}return s}function be(s){return typeof s=="boolean"||s==="true"||s==="false"}function Ce(s){return!isNaN(s)&&!isNaN(parseFloat(s))}function ce(s){return decodeURIComponent(globalThis.atob(s))}function me(s){return globalThis.btoa(encodeURIComponent(s))}class le{items=new Map;add(e,t){Array.isArray(e)?e.forEach(([r,a])=>{this.add(r,a)}):t&&(Array.isArray(t)||(t=[t]),this.items.set(e,t))}get(...e){const t=e.shift()||"";return this.items.get(t)?.map(r=>e.reduce((a,i)=>a.replace(/%\d+/,i),r))}}const m=new le;m.add("bad_args","Bad args");m.add("cant_find","Can't find %1");const de="/",F="ROOT",ue="CLOUD";function y(s){return typeof s=="object"&&"id"in s?s.id:s.replace(/.*[\\/:]{1,1}([^:\\/]+)$/,"$1")}function he(s){return/^[a-zA-Z0-9_-]+:/.test(s)}function fe(...s){return s.reduce((e,t)=>(e.push(...t.replace(/[\\/]+/,"/").replace(/^\//,"").replace(/\/$/,"").split("/")),e),[]).join("/").replace(/:\//,":").replace(/\/$/,"")}function ge(s){return s.replace(/([\w]*[\\:]).*/,"$1")}function we(s){return s.replace(/.*:([\w/.]+)$/,"$1")}function Ie(s){const e=ge(s),t=V(s);let r=we(s);return r=r.slice(0,r.length-t.length),e+r}function V(s){return/^.*[\\/:]([\w]+\.[\w]+)$/.test(s)?s.replace(/^.*[\\/:]([\w]+\.[\w]+)$/,"$1"):/^([\w]+\.[\w]+)$/.test(s)?s.replace(/^([\w]+\.[\w]+)$/,"$1"):""}function T(s){return s.replace(/(.*[\\/:]{1,1})[^:\\/]+$/,"$1")}function O(s){return s.length&&/^[\w .\\/:-]+$/.test(s)}function ye(s){return O(s)&&!!(s.includes("/")||s.match(/^([^:]+):.*/))}function pe(s){return s*1e3}function H(s){return s.replace(/^(.*)\.[^.]+$/,"$1")}function W(s){const e=s.match(/^.*\.([^.]*)$/);return e?e[1]:""}function Se(s){return s.replace(/[^.a-zA-Z0-9_-]/g,"_")}function C(s,e){return e?`${H(s)}.${e}`:s}function Z(s,e,t){let r=s;return e.hasItem(C(r,t))?(r=`copy_${s}`,e.hasItem(C(r,t))?Z(r,e,t):r):r}async function De(s){if(s.locked)throw new Error(m.get("FileSystemItem_itemLocked",await s.getPath())?.join(" "));return s}function S(s){const e=P(s);if(e){if(e?.locked)throw new Error(m.get("FileSystem_permissionsNeeded")?.join(" "));return s}return s}async function w(s,e){return e=e||P(s),e&&(await s.save(),await e.save()),s}async function ve(s,e){const t=await e.remove({recursive:s});return Array.isArray(t)?t:[t]}function P(s){if(s.storage)return s;if(s.parent)return P(s.parent)}class f{name;value;scope;constructor({name:e,value:t,scope:r}){this.name=e,this.value=t,this.scope=r}}const Ee={basic:d.BASIC,bas:d.BASIC,markdown:d.DISK_MARKDOWN,md:d.DISK_MARKDOWN,image:d.IMAGE,img:d.IMAGE};function _e(s,e=d.NOTE_BLANK){const t=Ee,r=W(s).toLowerCase();return t[r]||e}class Pe extends f{}class h{type;events;_locked=!1;parent;createdDate;editedDate;id;_name="";meta;_data;_action;constructor(e,{type:t,symbol:r=d.NOTE_BLANK}={type:"Unknown",symbol:d.NOTE_BLANK}){const{locked:a=!1,id:i,name:n=void 0,meta:o=void 0,data:c=void 0,action:l,createdDate:_=Date.now(),editedDate:I=void 0}=e;this.events=X(new J),this.createdDate=_||Date.now(),this.editedDate=I||_,this._locked=a||!1,this.id=i,this._name=n||"",this.type=t||"Unknown",this.meta=new Map([[D.SYMBOL,_e(i||"",r||d.NOTE_BLANK)],[D.VISIBLE,!0],...o||[]]);let L=c;if(typeof c=="string")try{L=JSON.parse(c)}catch(q){throw console.log(L),q}this._action=l,this._data=Te(L||{})}async remove(e={}){const{silent:t}=Object.assign({silent:!1},e);let r;const a=this.isLocked();if(!a)r={type:this.type,id:this.id,name:this.name,path:await this.getPath(),size:this.size,storage:P(this)};else if(!t)throw new Error(m.get("FileSystemItem_itemLocked",await this.getPath())?.join(" "));return(t||!a)&&(this.events.next(new f({name:"remove",value:{item:this}})),this.events.unsubscribe(),this.parent?.removeItem(this)),r?[r]:[]}isLocked(e=!1){return e?!1:this.parent&&this.parent.locked&&this.parent.id!==F?!0:this._locked}async copy(){const e=this.constructor,t=await this.export({encodeData:!1}),r=new e(t);return Promise.resolve(r)}rename(e,t={}){const{name:r=!1,ignore:a=!1}=Object.assign({name:!1,ignore:!1},t);if(!this.isLocked(a)){if(r)return this.name=e,this;{const i=this.id;this.id=Se(e||""),this.parent&&i!==this.id&&this.parent.changeItemId(this,i,this.id)}this.events.next(new Pe({name:"rename",value:{item:this}}))}return this}save(){this.events.next(new f({name:"save",value:{item:this}}))}getUsedMemory(){return this.size/this.maxSize}async export(e={}){const{encodeData:t}=Object.assign({encodeData:!0},e),r=new Map(this.meta);Array.from(r.keys()).forEach(i=>{r.get(i)instanceof Q&&r.set(i,r.get(i).toJSON())});let a;return t&&typeof this._data=="string"?a=await me(this._data):a=this._data,{type:this.type,id:this.id,name:this._name,createdDate:this.createdDate,editedDate:this.editedDate,data:a,meta:Array.from(r)}}get data(){let e=this._data;if(typeof this._data=="string")try{e=JSON.parse(this._data)}catch(t){console.error(t),e={type:"markdown",content:"Cannot parse data"}}return e}set data(e){typeof e=="object"&&(e=JSON.stringify(e)),this._data=e}get action(){return this._action}setId(e){this.id=e}setParent(e){this.parent=e}get locked(){return this.parent?.locked||this._locked}get name(){return this._name||this.id}set name(e){this._name=e||""}get extension(){return W(this.id)}get size(){const e=Object.values(this.data||{});return new Blob(e).size}get maxSize(){return new Blob(Object.values(this.data||{})).size}getRealMaxSize(){return new Blob(Object.values(this.data||{})).size}getBase(){return h.getBaseRecursive({item:this},!1)}getPath(){return h.getBaseRecursive({item:this})}static getBaseRecursive({item:e,path:t=[]},r=!0){if(r&&t.push(e.id),e.parent)return h.getBaseRecursive({item:e.parent,path:t});if(t=t.reverse(),t[0]===F&&t.shift(),t.length>0){let a=t[0];return/\./.test(a)||(a+=":"),`${a}${t.slice(1,t.length).join(de)}`}else return F}}m.add([["FileSystemItem_itemLocked",["Item Locked","Item is locked, can't be edit… %1"]]]);function Te(s){return typeof s=="object"&&(s=JSON.stringify(s)),s}class u extends h{items=new Map;_maxSize=pe(1);constructor(e,t){e={...e},super(e,t),this.addItems(e.items||this.items),this._maxSize=e.maxSize||this._maxSize}async export(e={}){const t={...await super.export(e),items:[]};return Reflect.deleteProperty(t,"data"),t.items=await Promise.all(Array.from(this.items.values()).map(r=>r.export())),t}async addItems(e,t=!1){let r=[];e instanceof Map?r=Array.from(e.values()):Array.isArray(e)&&(r=e),r=r.map(i=>(typeof i.data=="string"&&(i.data=ce(i.data)),i));const a=this.parseItems(r);return Promise.all(a.map(i=>this.addItem(i,t)))}static normalizeItemData(e){const t={...e},r=[];if("items"in e&&!(e.items instanceof Map)&&(t.items=new Map(e.items.map(a=>[a.id,a]))),"info"in e&&e.info)debugger;return"extension"in t&&(t.id+="."+t.extension,delete t.extension,r.push("extension")),"createTime"in t&&(t.createdDate=t.createTime,delete t.createTime,r.push("createTime")),"editTime"in t&&(t.editedDate=t.editTime,delete t.editTime,r.push("editTime")),"icon"in t&&(delete t.icon,r.push("icon")),r.length&&console.warn("@deprecated TODO: muss weg, hier werden die alten Items angepasst.",t,r),t}parseItems(e){return e.map(t=>{const r=u.normalizeItemData(t);let a;return r.type?a=N(r.type):"items"in r?a=N("Directory"):a=N(),new a(r)})}async addItem(e,t=!1){const r=e.parent;if(!t&&this.hasItem(e.id))throw new Error(`File ${e.id} exists`);if(r&&await r.removeItem(e),t){const a=W(e.id),i=H(e.id);e.setId(C(Z(i,this,a),a))}return this.items.set(e.id,e),e.setParent(this),e.events.next(new f({name:"move",value:{item:e,lastParent:r}})),this.events.next(new f({name:"addItem",value:{item:e}})),e}removeItem(e){return e.setParent(void 0),this.items.delete(e.id),this.events.next(new f({name:"removeItem",value:{item:e}})),Promise.resolve()}async remove(e={}){const{recursive:t}={recursive:!1,...e},r=[];if(t){const a=await this.getItems();for(const i of a.values())r.push(...await i.remove(e));return r.push(...await super.remove(e)),r}else{if((await this.getItems()).size>0)throw new Error(m.get("FileSystemItem_itemContainerNotEmpty",await this.getPath())?.join(" "));return await super.remove(e)}}changeItemId(e,t,r){this.items.delete(t),this.items.set(r,e),this.parent&&console.log("changeItemId by parent",t,r,this.parent.items)}getItems(){return Promise.resolve(this.items)}getItem(e){return this.items.get(e)}hasItem(e){return this.items.has(e)}get size(){return Array.from(this.items.values()).reduce(function(e,t){return t instanceof u||(e+=t.size),e},0)}get maxSize(){return e(this);function e(t){return t.parent&&t.getRealMaxSize()?e(t.parent):t.getRealMaxSize()}}}m.add([["FileSystemItem_itemContainerNotEmpty",["ItemWrapp Not Empty","ItemContainer not empty… %1"]]]);class E extends u{static TYPE="Storage";storage;constructor(e,t){e={...e,locked:!0},super(e,t),this.storage=e.storage}get locked(){return this.storage.locked}mount(...e){return this.storage.mount(...e)}unmount(...e){return this.storage.unmount(...e)}async save(){return this.storage.save(await this.export())}}class A extends E{static TYPE="CloudDisk";constructor(e){super(e,{type:A.TYPE,symbol:d.CLOUD_DISK})}isLogged(e=!1){return e||this.storage.storage?.isLogged()||!1}isLocked(e){return this.isLogged(e)&&super.isLocked(e)}}class $ extends u{static TYPE="Directory";constructor(e){super(e,{type:"Directory",symbol:d.DIRECTORY}),[D.WINDOW_SCALE,D.WINDOW_SCROLL_X,D.WINDOW_SCROLL_Y].forEach(t=>{this.meta.has(t)||this.meta.set(t,!0)})}}class k extends h{static TYPE="File";constructor(e){super(e,{type:"File"})}}class K extends u{static TYPE="FloppyDisk";constructor(e){super(e,{type:"FloppyDisk"})}}class B extends E{static TYPE="HardDisk";constructor(e){super(e,{type:"HardDisk",symbol:d.HARD_DISK})}}class z extends h{static TYPE="Link";refPath;constructor(e){e={refPath:void 0,...e},super(e),this.refPath=e.refPath}}class Y extends E{static TYPE="RamDisk";constructor(e){super(e,{type:"RamDisk",symbol:d.RAM_DISK})}}class Me extends u{static TYPE="Root";constructor(e){e={...e,locked:!0,id:"ROOT",name:"ROOT"},super(e,{type:"Root"})}}class j extends E{static TYPE="TmpDisk";constructor(e){super(e,{type:"TmpDisk",symbol:d.TMP_DISK}),this.meta.set(D.VISIBLE,!1),this.meta.set(D.IGNORE_SYMBOL_REARRANGE,!0)}}class v extends u{static TYPE="Trashcan";constructor(e){super(e,{type:"Trashcan",symbol:d.TRASHCAN})}}class g{static PREFIX={FLOPPY_DISK:"DF",TMP:"TMP",RAM:"RAM",HARD_DISK:"HD",CLOUD_DISK:"CD"};static TMP_DISK_NAME="TMP";static TMP_DISK_TITLE="TMP DISK";static RAM_DISK_NAME="RAM";static RAM_DISK_TITLE="RAM DISK";static HARD_DISK_NAME="HARD DISK";name;root;currentItem;storages=new Map;events=X(new J);constructor(e){this.name=e,this.root=new Me,this.setup()}setup(){this.currentItem=this.root;const e=[this.addStorage(g.RAM_DISK_TITLE,p.SESSION,{id:g.RAM_DISK_NAME}),this.addStorage(g.HARD_DISK_NAME,p.LOCAL,{trashcan:!0}),this.addStorage(g.TMP_DISK_TITLE,p.TEMP,{id:g.TMP_DISK_NAME,trashcan:!1})];return Promise.all(e).catch(t=>{throw t})}createTmpFile(e,t,r,a){return this.createRootFile(`TMP:${e}`,t,r,a)}createRootDir(e,t,r){const a=`${e}`;return this.makedir(a,t,{override:!0,...r})}createRootFile(e,t,r,a){let i=t,n=r;typeof t=="object"&&(n=t,i=void 0);const o=`${e||"Unknown"}`;return this.makeFile(o,i,n,{...a||{},override:!0})}async get(e,t=!1){if(e instanceof h)return e;if(O(e))try{return await this.parsePath(e)}catch(r){if(t)return new h({id:y(e),name:y(e)});throw r}else throw m.get("FileSystem_pathInvalid",y(e),T(e))}async parsePath(e){let t=e,r=this.currentItem;const a=e.match(/^([^:\\/]+):(.*)$/);if(a?(r=this.root?.getItem(a[1]),t=a[2]):t[0]==="/"&&this.currentItem?(t=t.slice(1),r=P(this.currentItem)):t==="ROOT"?(r=this.root,t=""):t&&!t.includes("/")&&!/^\.+$/.test(t.trim())&&(r=this.root.getItem(t),t=""),t&&t.length>0&&(r=U(t.split("/"),r)),r)return r;throw m.get("FileSystem_pathInvalid",e,await this.currentItem?.getBase()||"")}async addFloppyDisk(e){let t;if(typeof e=="function"?(t=await e(),t instanceof Promise&&(t=await t)):t=e,Array.isArray(t))throw new Error('data is an Array, use "defineFloppyDisk" for define a Disk');return this.addStorage(t)}async removeFloppyDisk(e){await e.remove({silent:!0})}async addStorage(e,t,r={}){r=Object.assign({id:null},r);let a;typeof t=="function"&&(a=t,t=p.CLOUD);const i=this.getFreeSlot(g.PREFIX.FLOPPY_DISK),n={id:i,itemClass:K,items:new Map};let o={};if(typeof e=="object"){const c=e;n.name=c.name||c.id,c.items&&(n.items=c.items),n.meta=Array.from(new Map([[D.SYMBOL,d.DISK_1],...c.meta||[]]))}else{switch(t){case p.SESSION:n.id=g.PREFIX.RAM,n.itemClass=Y;break;case p.TEMP:n.id=g.PREFIX.TMP,n.itemClass=j;break;case p.LOCAL:n.id=this.getFreeSlot(g.PREFIX.HARD_DISK),n.itemClass=B;break;case p.CLOUD:n.id=this.getFreeSlot(g.PREFIX.CLOUD_DISK),n.itemClass=A;break}n.id=r.id||n.id;let c;a&&typeof a=="function"?c=await this.registerStorageByStorage(n.id,a).mount(r):c=await this.registerStorageByType(n.id,t).mount(r);const l=await c.load();o=u.normalizeItemData(l),n.storage=c,p.NONE!==t&&(n.name=o.name||o.id||e)}return(n.meta=n.meta||[]).push(...o.meta||[]),this.addDisk({...n,...o,storage:n.storage||new b({id:i,name:g.TMP_DISK_TITLE})},r)}removeStorage(e){return e.unmount().then(()=>(this.events.next(new f({name:"removeStorage",value:{itemStorage:e}})),e))}registerStorageByType(e,t){const r=ne(t),a=`${this.name}_${e}`,i=new r({id:e,name:a});return this.storages.set(a,i),i}registerStorageByStorage(e,t){const r=`${this.name}_${e}`,a=new t({id:e,name:r});return this.storages.set(r,a),a}connect(e,t){return this.addStorage(ue,e,t).then(r=>r).catch(r=>{throw r})}async disconnect(e){return e=await this.removeStorage(e),e.remove({silent:!0,recursive:!0}),e}addDisk({id:e,name:t,meta:r,items:a,itemClass:i,storage:n},o){o={trashcan:!1,...o},a instanceof Map&&o.trashcan&&(!a||a&&!a.has(v.TYPE))&&(a=a||new Map,a.set(v.TYPE,{type:v.TYPE,id:v.TYPE,name:v.TYPE}));const c=i;if(!c)throw new Error("ItemClass is empty!");const l=new c({id:e,name:t||e,meta:r,items:a,storage:n});return this.root?.addItem(l),this.events.next(new f({name:"addDisk",value:{id:e,item:l}})),l}getFreeSlot(e){let t=0;for(;this.root?.hasItem(`${e}${t}`);)t++;return`${e}${t}`}async exist(e){try{return!!await this.get(e)}catch(t){return console.error(t),!1}}async changeDirectory(e){const t=await this.get(e);return this.currentItem=t,this.events.next(new f({name:"changeDirectory",value:t})),t}async makedir(e,t,r){const{override:a,meta:i}={override:!1,meta:[],...r};let n;e&&ye(e)&&e!==t?n=await this.get(T(e)):n=this.currentItem;const o=new $({id:y(e),name:t||"",createdDate:Date.now(),meta:i});if(await S(n),a||!n.getItem(o.id))n.addItem(o,a),this.events.next(new f({name:"writeItem",value:o}));else throw m.get("FileSystem_fileExist",o.id);return await w(n),o}async makeFile(e,t,r,a){const{override:i,meta:n}={...a,meta:a.meta||[]},o=y(e),c=new k({id:o,name:t||o,data:r,meta:n,createdDate:Date.now()});if(!O(e))throw m.get("FileSystem_invalidPath",e);let l=Ie(e);const _=V(e);l===_&&(l=".");let I;if(he(l)?I=await this.get(l):this.currentItem?.id!=="ROOT"?I=await this.get(fe(await this.currentItem?.getPath()||"",l)):I=await this.get(l),I.hasItem(_))if(i)await I.getItem(_)?.remove(),I.addItem(c);else throw m.get("FileSystem_fileExist",c.id);else I.addItem(c),this.events.next(new f({name:"writeItem",value:c}));return await w(I),c}async editFile(e,t){const r=await this.get(e);return await S(r),await De(r),r.data=t,w(r)}async editFileMeta(e,t,r){const a=await this.get(e);return Array.isArray(t)?t.map(i=>({name:i[0],value:i[1]})):a.meta.set(t,r),w(a)}async cleanFileMeta(e,{force:t}={}){const r=await this.get(e);return await S(r),r.meta=t?new Map:new Map(Array.from(r.meta.entries()).filter(([,a])=>a!==void 0)),w(r)}async getItemMetaList(e){const t=await this.get(e);return Array.from(t.meta).map(r=>({name:r[0],value:r[1]}))}async saveItem(e){const t=await this.get(e);return w(t)}async makelink(e,t=null){const r=await this.get(e);await S(r);const a=this.currentItem,i=new z({id:H(r.id)+".ref",name:`${t||r.name}`,createdDate:Date.now(),meta:[[D.REFERENCE,await r.getPath()]]});return await a.addItem(i),await w(r),i}async editlink(e,t){const r=await this.get(e);await S(r);const a=await this.get(t);return r.refPath=await a.getPath(),w(r)}async rename(e,t,{name:r,removeName:a}={name:!1,removeName:!1}){let i;if(e instanceof h)i=e;else if(O(e)||typeof e=="string")i=await this.get(e);else throw m.get("FileSystem_pathInvalid",T(e),e);return await S(i),a&&(r=!0,t=void 0),await i.rename(t,{ignore:!0,name:r}),w(i)}async copy(e,t,r={ignore:!1}){const{ignore:a}={ignore:!1,...r};let i,n,o;if(e instanceof h?(n=e,i=e.id):(n=await this.get(e),i=y(e)),t instanceof h)t instanceof u||(t=t.parent),o=t;else if(t){i=y(t);const l=await this.get(t,!0);if(l.parent?o=l.parent:o=await this.get(T(t)),!(o instanceof u))throw new Error("no ItemContainer")}else throw new Error('"to" is empty!');await S(n);const c=await n.copy();if(o instanceof u&&(a||!o.getItem(i)))c.rename(i),o.addItem(c,a),this.events.next(new f({name:"copyItem",value:c}));else throw m.get("FileSystem_fileExist",i);return w(c)}async move(e,t,{override:r}={}){let a,i,n;if(e instanceof h)i=e,a=e.id;else{if(i=await this.get(e),i instanceof E)throw m.get("FileSystem_cantMoveStorage",i.id);a=y(e)}if(t instanceof h)t instanceof u?n=t:n=t.parent;else{if(a=y(t),n=await this.get(t),n instanceof u)a=y(e);else return this.get(T(t));if(!(n instanceof u))throw new Error("no ItemContainer")}let o;if(await S(i),r||!await n.getItem(a))o=P(i),await i.rename(a),await n.addItem(i,r),this.events.next(new f({name:"moveItem",value:i}));else throw m.get("FileSystem_fileExist",i.id,a);return await w(i),o?o.save().then(()=>i):i}async remove(e,t,r={ignore:!1}){const{ignore:a}={ignore:!1,...r},i=await this.get(e);await S(i);try{const n=await ve(t,i);return n[n.length-1].storage&&await n[n.length-1].storage?.save(),n}catch(n){if(!a)throw n}}}function U(s,e){const t=s.shift();if(t===void 0)return e;if(t===".."){if(e.parent)return e.parent}else if(t==="."||t==="")return U(s,e);if(e){const r=e.getItem(t);return s.length>0&&r instanceof u?U(s,r):r}}function N(s){switch(s){case $.TYPE:return $;case v.TYPE:return v;case E.TYPE:return E;case j.TYPE:return j;case Y.TYPE:return Y;case B.TYPE:return B;case K.TYPE:return K;case A.TYPE:return A;case z.TYPE:return z;case k.TYPE:return k}return k}m.add([["FileSystem_invalidPath",["Invalid File",'Invalid path "%1"']],["FileSystem_invalidFile",["Invalid File",'Invalid file… "%1"']],["FileSystem_fileExist",["File Ready",'File already exists… "%1"']],["FileSystem_pathInvalid",["Path Invalid",'Path invalid… "%1"; base: "%2"']],["FileSystem_itemInvalid",["Item Invalid",'Item id invalid… "%1" from "%2"']],["FileSystem_cantMoveStorage",["Can't Move",`Can't move BaseStorage "%1"`]],["FileSystem_permissionsNeeded",["Permissions needed","Permissions needed"]]]);export{ie as C,$ as D,f as E,g as F,E as I,Me as R,M as S,p as T,W as a,be as b,v as c,u as d,m as e,Se as f,ne as g,y as h,Ce as i,ce as j,C as k,k as l,Fe as m,Re as n,h as o,fe as p,Ie as q,me as r,w as s,Ne as u,Le as w};
