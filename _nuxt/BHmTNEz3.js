function isArray(t){return Array.isArray(t)||ArrayBuffer.isView(t)}function multQuatVec(t,e){const{x:r,y:n,z:o}=e,{x:s,y:i,z:c,w:h}=t,u=h*r+i*o-c*n,a=h*n+c*r-s*o,l=h*o+s*n-i*r,y=-s*r-i*n-c*o,d=u*h+y*-s+a*-c-l*-i,m=a*h+y*-i+l*-s-u*-c,w=l*h+y*-c+u*-i-a*-s;return new e.constructor(d,m,w)}const t=Math.PI,e=2*Math.PI;function normRad(r){let n=r%e;return n<-t?n+=e:n>t&&(n-=e),n}function isNumber(t){return"number"==typeof t||(null==t?void 0:t.constructor)===Number}const r=0,n=1,o=2,s=3,i=9999999999999,c=void 0,h=Symbol("vector length"),u=Symbol("get source"),a=Symbol("checked");let l,y,d=c;const m=[0,1,2,6,24,120,720,5760,51840,518400,5702400,68428800,889574400,12454041600,186810624e3],w=[];let g=-1,f=!1;const x=[];function handleProgess(t,e,r){d=t,g=-1,y=1;const n=e(r);if(!isNumber(n))throw new Error("\n      your assigned progress did not not return a primitive!\n      calc() does not support logical operators (|| && ==) directly\n\n      instead of calc(() => v1 || v2);\n      use        calc(() => +v1 || +v2);\n\n      instead of calc(() => v1);\n      use        calc(v1);\n      ");return n}function getVectorLength(t){const e=t[u];return e?e(t).length:t[h]||3}function setVectorValue(t,e,i){const c=t[u];c?c(t)[e]=i:e!==r?e!==n?(e===o&&(t.z=i),e===s&&(t.w=i)):t.y=i:t.x=i}function operatorCalc(t,e=void 0){if("function"!=typeof t)throw new Error("no function assigned");if(d!==c)throw new Error("something wrong, do you use calc() inside calc?");try{const n=void 0===e,o="function"==typeof e,s=o||n?void 0:e,c=handleProgess(r,t,s);if(n&&void 0===l)return c;const h=l?getVectorLength(l):0;if(h===i){if(!t[a]){const e=handleProgess(i,t),r=m[y];if(Math.abs(e-r)>Number.EPSILON)throw new Error("\n            algebraic multiplication works only in calls with *\n\n            calc(() => v * m);\n            calc(() => m * v);\n            calc(() => m * m);\n            calc(() => m * m * v);\n\n            ");t[a]=!0}let e=w[0];for(let t=1;t<y-1;t+=1){const r=w[t];if(!e.multiply)throw new Error(`cannot find method multiply() on ${e}`);e=e.multiply(r)}return e}let u=o?e.length:h;if(u||(u=h),u<h)throw new Error("Your assigned result Vector cant use higher space Operands than it has");const g=new Array(u);g[0]=c,s&&setVectorValue(s,d,g[0]);for(let e=1;e<u;e+=1){const r=handleProgess(e,t,s);g[e]=r,s&&setVectorValue(s,d,r)}return n?new l.constructor(...g):o?e(...g):s}finally{d=c,l=void 0}}function cachedValueOf(t,e){const h=t.prototype;h[u]=e;const a=h[Symbol.toPrimitive]||function(t){return"string"===t?this.toString():this.valueOf()};h[Symbol.toPrimitive]=function(t){return d===r&&(l=l?function maxVector(t,e){return getVectorLength(t)>getVectorLength(e)?t:e}(l,this):this,w[y-1]=this),d===c?a.call(this,t):function getVectorValue(t,e){if(y+=1,e===i)return y;if(e>=getVectorLength(t))return 0;const c=t[u];return c?1*c(t)[e]:e===r?1*t.x:e===n?1*t.y:e===o?1*t.z:e===s?1*t.w:void 0}(this,d)}}function bindCache(t){return function(...e){if(d===r){if(f)return t.apply(this,e);try{f=!0,g+=1;const r=t.apply(this,e);return x[g]=r,r}finally{f=!1}}return d===n||d===o||d===s?(g+=1,x[g]):t.apply(this,e)}}function cachedMethod(t,e){const r=t.prototype,n=r[e];r[e]=bindCache(n)}function cachedGetter(t,e){const r=t.prototype,n=Object.getOwnPropertyDescriptor(r,e);Object.defineProperty(r,e,{get:bindCache(function(){return n.get.call(this)})})}function defineVectorLength(t,e){const r=t.prototype;Object.defineProperty(r,h,{value:e})}function defineMatrixLength(t){defineVectorLength(t,i)}function cachedFunction(t){return bindCache(t)}function convertToCSSVars(t,e,r={}){const n=function getVarPrefix(t){let e="";return t&&(e=`${t}-`),e}(t);return Object.entries(e).forEach(([t,e])=>{r[`--${n}${t}`]=e}),r}"undefined"!=typeof DOMPoint&&(t=>{try{cachedValueOf(t),defineVectorLength(t,4)}catch(e){console.error("error while hijackDOMPoint"),console.error(e)}})(DOMPoint);const p=Symbol("axes");function square$1(t){return t*t}class APoint{constructor(...t){"function"==typeof t[0]?operatorCalc(t[0],(t,e)=>{this[p]=[t,e]}):isArray(t[0])?this[p]=[...t[0]]:t[0]&&isNumber(t[0].x)?this[p]=[t[0].x||0,t[0].y||0]:this[p]=[t[0]||0,t[1]||0]}valueOf(){throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc")}normalize(){const{length:t}=this;return new this.constructor(this.x/t,this.y/t)}norm(){return this.normalize()}dot(t){return this.x*t.x+this.y*t.y}getRad(){return normRad(Math.atan2(this.y,this.x))}angleTo(t){return function angleOverGround(t,e,r,n){return normRad(Math.atan2(t,e)-Math.atan2(r,n))}(this.y,this.x,t.y,t.x)}rotate(t){const e=Math.sin(t),r=Math.cos(t),n=this.x*r-this.y*e,o=this.x*e+this.y*r;return new this.constructor(n,o)}distance(t){return Math.sqrt(square$1(this.x-t.x)+square$1(this.y-t.y))}dist(t){return this.distance(t)}toArray(){return[this.x,this.y]}calc(t){throw new Error("calc() not implemented")}clone(){throw new Error("clone() not implemented")}equals(t){return this.x===t.x&&this.y===t.y}toJSON(){return{x:this.x,y:this.y}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e={}){return convertToCSSVars(t,this.toJSON(),e)}get lengthSq(){return this.dot(this)}get length(){return Math.sqrt(this.lengthSq)}get lensq(){return this.lengthSq}get len(){return this.length}get x(){return this[p][0]}set x(t){throw new Error("set x() not implemented")}get y(){return this[p][1]}set y(t){throw new Error("set y() not implemented")}get z(){throw new Error("get z() not implemented")}set z(t){throw new Error("set z() not implemented")}[Symbol.iterator](){return this[p].values()}}cachedValueOf(APoint),defineVectorLength(APoint,2),cachedMethod(APoint,"dot"),cachedMethod(APoint,"angleTo"),cachedMethod(APoint,"distance"),cachedMethod(APoint,"toArray"),cachedMethod(APoint,"getRad"),cachedGetter(APoint,"length"),cachedGetter(APoint,"lengthSq");class Point extends APoint{set x(t){this[p][0]=t}set y(t){this[p][1]=t}get x(){return this[p][0]}get y(){return this[p][1]}calc(t){return operatorCalc(t,this)}clone(){return new Point(this.x,this.y)}}class IPoint extends APoint{toPoint(){return new Point(this.x,this.y)}}const z=cachedFunction((t,e)=>new Point(t,e)),point=(t,e)=>z(t,e),V=cachedFunction((t,e)=>new IPoint(t,e)),ipoint=(t,e)=>V(t,e);ipoint(0,0),ipoint(0,-1),ipoint(-1,0);const S=Symbol("axes");function square(t){return t*t}class AVector{constructor(...t){"function"==typeof t[0]?operatorCalc(t[0],(t,e,r)=>{this[S]=[t,e,r]}):isArray(t[0])?this[S]=[...t[0]]:t[0]&&isNumber(t[0].x)?this[S]=[t[0].x||0,t[0].y||0,t[0].z||0]:this[S]=[t[0]||0,t[1]||0,t[2]||0]}valueOf(){throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc")}normalize(){const{length:t}=this;return new this.constructor(this.x/t,this.y/t,this.z/t)}norm(){return this.normalize()}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){return new this.constructor(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}crossNormalize(t){const e=this.cross(t),{length:r}=e;return e[S][0]/=r,e[S][1]/=r,e[S][2]/=r,e}cn(t){return this.crossNormalize(t)}toAngles(){return{theta:Math.atan2(this.z,this.x),phi:Math.asin(this.y/this.length)}}angleTo(e){return normRad(function acos(e){return e>-1?e<1?Math.acos(e):0:t}(this.dot(e)/(this.length*e.length)))}multiply(t){return void 0===t.x?this.multiplyMat3(t):void 0===t.w?this.multiplyVec3(t):multQuatVec(t,this)}multiplyMat3(t){return function multiplyVecMat3(t,[e,r,n]){return new t.constructor(t.dot(e),t.dot(r),t.dot(n))}(this,t)}multiplyVec3({x:t,y:e,z:r}){return new this.constructor(this.x*t,this.y*e,this.z*r)}distance(t){return Math.sqrt(square(this.x-t.x)+square(this.y-t.y)+square(this.z-t.z))}dist(t){return this.distance(t)}toArray(){return[this.x,this.y,this.z]}swizzle(t){const e=t.split("").map(t=>this[t]);return 2===e.length?new IPoint(e[0],e[1]):new this.constructor(e[0],e[1],e[2])}calc(t){throw new Error("calc() not implemented")}clone(){throw new Error("clone() not implemented")}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}toJSON(){return{x:this.x,y:this.y,z:this.z}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e={}){return convertToCSSVars(t,this.toJSON(),e)}get lengthSq(){return this.dot(this)}set lengthSq(t){throw new Error("set lengthSq() not implemented")}get length(){return Math.sqrt(this.lengthSq)}set length(t){throw new Error("set length() not implemented")}get lensq(){return this.lengthSq}set lensq(t){throw new Error("set lensq() not implemented")}get len(){return this.length}set len(t){throw new Error("set len() not implemented")}get x(){return this[S][0]}set x(t){throw new Error("set x() not implemented")}get y(){return this[S][1]}set y(t){throw new Error("set y() not implemented")}get z(){return this[S][2]}set z(t){throw new Error("set z() not implemented")}get xy(){return new IPoint(this[S][0],this[S][1])}set xy(t){throw new Error("set xz() not implemented")}get xz(){return new IPoint(this[S][0],this[S][2])}set xz(t){throw new Error("set xz() not implemented")}get yz(){return new IPoint(this[S][1],this[S][2])}set yz(t){throw new Error("set yz() not implemented")}[Symbol.iterator](){return this[S].values()}}cachedValueOf(AVector),defineVectorLength(AVector,3),cachedMethod(AVector,"dot"),cachedMethod(AVector,"cross"),cachedMethod(AVector,"crossNormalize"),cachedMethod(AVector,"toAngles"),cachedMethod(AVector,"angleTo"),cachedMethod(AVector,"rotate"),cachedMethod(AVector,"distance"),cachedMethod(AVector,"toArray"),cachedGetter(AVector,"length"),cachedGetter(AVector,"lengthSq");class Vector extends AVector{set x(t){this[S][0]=t}set y(t){this[S][1]=t}set z(t){this[S][2]=t}get x(){return this[S][0]}get y(){return this[S][1]}get z(){return this[S][2]}calc(t){return operatorCalc(t,this)}clone(){return new Vector(this.x,this.y,this.z)}}class Victor extends AVector{toVector(){return new Vector(this.x,this.y,this.z)}clone(){return this}}const A=cachedFunction((t,e,r)=>new Victor(t,e,r)),victor=(t,e,r)=>A(t,e,r);victor(0,0,0);const M=victor(0,0,-1);victor(0,0,1);const v=victor(-1,0,0);victor(1,0,0);const O=victor(0,1,0);victor(0,-1,0),victor(1,1,1);const b=Symbol("angle rad"),E=Math.PI/180;class ADegree{constructor(t){this[b]=t instanceof ADegree?t[b]:normRad(t*E)}valueOf(){return this[b]}toJSON(){return{angle:this[b]}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e={}){return convertToCSSVars(t,this.toJSON(),e)}}class Degree extends ADegree{set(t){this[b]=t instanceof ADegree?t[b]:normRad((t||0)*E)}}new class IDegree extends ADegree{toDegree(){return new Degree(this[b])}}(0);const P=Symbol("axes"),N=Symbol("forward cache"),q=Symbol("left cache"),C=Symbol("up cache"),J=Symbol("inverse cache");function normalize(t){const e=function length([t,e,r,n]){return Math.sqrt(t*t+e*e+r*r+n*n)}(t);t[0]/=e,t[1]/=e,t[2]/=e,t[3]/=e}function getQuat(t,e,r,n){return isNumber(t)?[t,e,r,n]:isArray(t)?[...t]:function isAngle(t){return isNumber(t)||t instanceof ADegree}(e)?function axisAngle(t,e){const r=new Array(4),n=.5*e,o=Math.sin(n),s=Math.cos(n);return r[0]=o*t.x,r[1]=o*t.y,r[2]=o*t.z,r[3]=s,r}(t,e):t&&e?function look(t,e){const r=t.normalize(),n=e.crossNormalize(r),o=r.crossNormalize(n),s=n.x,i=n.y,c=n.z,h=o.x,u=o.y,a=o.z,l=r.x,y=r.y,d=r.z,m=s+u+d,w=new Array(4);if(m>0){let t=Math.sqrt(m+1);return w[3]=.5*t,t=.5/t,w[0]=(a-y)*t,w[1]=(l-c)*t,w[2]=(i-h)*t,w}if(s>=u&&s>=d){const t=Math.sqrt(1+s-u-d),e=.5/t;return w[0]=.5*t,w[1]=(i+h)*e,w[2]=(c+l)*e,w[3]=(a-y)*e,w}if(u>d){const t=Math.sqrt(1+u-s-d),e=.5/t;return w[0]=(h+i)*e,w[1]=.5*t,w[2]=(y+a)*e,w[3]=(l-c)*e,w}const g=Math.sqrt(1+d-s-u),f=.5/g;return w[0]=(l+c)*f,w[1]=(y+a)*f,w[2]=.5*g,w[3]=(i-h)*f,w}(t,e):void 0}class AQuaternion{constructor(t,e,r,n){this[P]=function from(t,e,r,n){return t&&isNumber(t.w)?getQuat(t.x,t.y,t.z,t.w):getQuat(t,e,r,n)||[0,0,0,1]}(t,e,r,n),normalize(this[P])}set(t,e,r,n){throw new Error("set x() not implemented")}multiply(t,e,r,n){if(isNumber(t.w))return this.multiplyQuaternion(t);const o=getQuat(t,e,r,n);return o?this.multiplyQuaternion(new this.constructor(o)):this.multiplyVector(t)}multiplyVector(t){return multQuatVec(this,t)}multiplyQuaternion(t){const e=this.x,r=this.y,n=this.z,o=this.w,s=t.x,i=t.y,c=t.z,h=t.w,u=o*s+e*h+r*c-n*i,a=o*i+r*h+n*s-e*c,l=o*c+n*h+e*i-r*s,y=o*h-e*s-r*i-n*c;return new this.constructor(u,a,l,y)}mul(t,e,r,n){return this.multiply(t,e,r,n)}get inverse(){const{x:t,y:e,z:r,w:n}=this;return this.constructor(-1*t,-1*e,-1*r,n)}get inv(){return this.inverse}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z&&this.w===t.w}get left(){return this.multiplyVector(v)}get dir(){return this.multiplyVector(M)}get up(){return this.multiplyVector(O)}get 0(){return this.left}get 1(){return this.dir}get 2(){return this.up}get x(){return this[P][0]}set x(t){throw new Error("set x() not implemented")}get y(){return this[P][1]}set y(t){throw new Error("set y() not implemented")}get z(){return this[P][2]}set z(t){throw new Error("set z() not implemented")}get w(){return this[P][3]}set w(t){throw new Error("set w() not implemented")}toJSON(){const{x:t,y:e,z:r,w:n}=this;return{x:t,y:e,z:r,w:n,a1:1-e*e*2-r*r*2,a2:t*e*2-r*n*2,a3:t*r*2+e*n*2,b1:t*e*2+r*n*2,b2:1-t*t*2-r*r*2,b3:e*r*2-t*n*2,c1:t*r*2-e*n*2,c2:e*r*2+t*n*2,c3:1-t*t*2-e*e*2}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e={}){return convertToCSSVars(t,this.toJSON(),e)}}function fromCache(t,e,r){let n=t[e];return n||(n=r(),t[e]=n),n}cachedValueOf(AQuaternion),defineMatrixLength(AQuaternion);class IQuaternion extends AQuaternion{get left(){return fromCache(this,q,()=>this.multiplyVector(v))}get dir(){return fromCache(this,N,()=>this.multiplyVector(M))}get up(){return fromCache(this,C,()=>this.multiplyVector(O))}get inverse(){return fromCache(this,J,()=>{const{x:t,y:e,z:r,w:n}=this;return this.constructor(-1*t,-1*e,-1*r,n)})}}const Q=cachedFunction((t,e,r,n)=>new IQuaternion(t,e,r,n));new IQuaternion(v,function degree(t){return new Degree(t)}(90)),Q(0,0,0,1);const I=Symbol("axes");class AColor{constructor(t,e,r,n){"function"==typeof t?operatorCalc(t,(t,e,r,n)=>{this[I]=[t,e,r,n]}):isArray(t)?this[I]=[...t]:t&&isNumber(t.x)?this[I]=[t.x||0,t.y||0,t.z||0,t.w||0]:this[I]=[t||0,e||0,r||0,n||0]}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}valueOf(){throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc")}toArray(){return[this.x,this.y,this.z,this.w]}calc(t){throw new Error("calc() not implemented")}clone(){throw new Error("clone() not implemented")}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z&&this.w===t.w}toJSON(){return{x:this.x,y:this.y,z:this.z,w:this.w}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,e={}){return convertToCSSVars(t,this.toJSON(),e)}get x(){return this[I][0]}set x(t){throw new Error("set x() not implemented")}get y(){return this[I][1]}set y(t){throw new Error("set y() not implemented")}get z(){return this[I][2]}set z(t){throw new Error("set z() not implemented")}get w(){return this[I][3]}set w(t){throw new Error("set w() not implemented")}[Symbol.iterator](){return this[I].values()}}cachedValueOf(AColor),defineVectorLength(AColor,4),cachedMethod(AColor,"toArray");const D=Symbol("data");class AMat3{constructor(...t){this[D]=t}get 0(){return this[D][0]}set 0(t){throw new Error("set [0] not implemented")}get 1(){return this[D][1]}set 1(t){throw new Error("set [1] not implemented")}get 2(){return this[D][2]}set 2(t){throw new Error("set [2] not implemented")}multiplyMat(t){return function multiplyMat3Mat3(t,[e,r,n]){const[o,s,i]=t;return new t.constructor(new o.constructor(o.x*e.x+s.x*e.y+i.x*e.z,o.y*e.x+s.y*e.y+i.y*e.z,o.z*e.x+s.z*e.y+i.z*e.z),new o.constructor(o.x*r.x+s.x*r.y+i.x*r.z,o.y*r.x+s.y*r.y+i.y*r.z,o.z*r.x+s.z*r.y+i.z*r.z),new o.constructor(o.x*n.x+s.x*n.y+i.x*n.z,o.y*n.x+s.y*n.y+i.y*n.z,o.z*n.x+s.z*n.y+i.z*n.z))}(this,t)}multiplyVec(t){return function multiplyMat3Vec(t,{x:e,y:r,z:n}){const[o,s,i]=t;return new o.constructor(o.x*e+s.x*r+i.x*n,o.y*e+s.y*r+i.y*n,o.z*e+s.z*r+i.z*n)}(this,t)}multiply(t){if(t instanceof AMat3)return this.multiplyMat(t);const{x:e,y:r,z:n}=t;if(void 0===e||void 0===r||void 0===n)throw new Error(`multiply only works with mat3 and vec3, not supported ${t}`);return this.multiplyVec(t)}[Symbol.iterator](){return this[D].values()}}cachedValueOf(AMat3),defineMatrixLength(AMat3);export{IPoint as I,ipoint as i,operatorCalc as o,point as p,victor as v};
