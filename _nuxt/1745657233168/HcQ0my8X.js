var $e=Object.defineProperty;var ue=a=>{throw TypeError(a)};var be=(a,e,t)=>e in a?$e(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var p=(a,e,t)=>be(a,typeof e!="symbol"?e+"":e,t),ce=(a,e,t)=>e.has(a)||ue("Cannot "+t);var n=(a,e,t)=>(ce(a,e,"read from private field"),t?t.call(a):e.get(a)),m=(a,e,t)=>e.has(a)?ue("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(a):e.set(a,t),w=(a,e,t,r)=>(ce(a,e,"write to private field"),r?r.call(a,t):e.set(a,t),t);var y=(a,e,t,r)=>({set _(i){w(a,e,i,t)},get _(){return n(a,e,r)}});import{M as Te}from"./viZ09Zwr.js";import{f as he,a as le,l as Ae,r as Ne}from"./BZctIkfj.js";import{u as E,B as se,A as V,D as Q,h as Ie}from"./DhoRlVJU.js";import{c as pe}from"./C5mdboMC.js";import{d as Pe,A as me}from"./CiKic5u-.js";import{I as q}from"./JDFt9gvC.js";import"./DDYNGWqS.js";import"./C6aID195.js";import"./2o4skMhU.js";import"./Cpj98o6Y.js";var ae=(a=>(a.STRING="string",a.ANY="any",a.INTEGER="integer",a.TERM="term",a.BOOLEAN="boolean",a.DOUBLE="double",a))(ae||{});function _(a,e){return a.separator===e}function ye(a){return{rawCommand:"",mergeArgs:!1,mergeArgsBy:/^[+,]$/,hasProgram:!1,activeArgument:void 0,isLongArgument:!1,isKeyWordArgument:!1,isString:!1,stringTmpValue:void 0,additionSpecial:!1,specialChar:["+",";",","],isBufferWrite:!1,isBufferValue:!1,isBufferString:!1,rawBuffer:void 0,lastChar:void 0,isSeparating:!1,escaped:!1,currentTick:Ee,isClamp:!1,...a,separator:a.separator||de}}function k(a,{separator:e,forceProgram:t,mergeArgs:r,mergeArgsBy:i}={}){var c,u;const s=ye({separator:e||de});a=`${String(a).trim()}${s.separator}`,s.rawCommand=a,s.mergeArgs=r||!1,s.mergeArgsBy=i||s.mergeArgsBy;const o=[];for(;s.rawCommand.length;){const h=s.rawCommand[0];s.rawCommand=s.rawCommand.slice(1);const l=s.rawCommand[0];if(_(s,l)){if(s.isSeparating&&_(s,h))s.isSeparating=!1;else if(!s.isBufferWrite&&_(s,h)){s.isSeparating=!0;continue}}else s.isSeparating=!1;if((_(s,h)&&!s.isClamp||s.rawCommand.length<1)&&(!s.escaped&&s.isBufferValue&&!s.isBufferString&&(s.isBufferWrite=!1),!s.isBufferWrite&&(s.isBufferValue&&Me(s),s.activeArgument))){Fe(s,o);continue}if(h===ge&&s.activeArgument){s.isKeyWordArgument=!0;continue}else if((h===re&&(/[ +a-zA-Z]/.test(l)||l===re)||s.activeArgument&&!s.isKeyWordArgument)&&!s.isBufferWrite&&!s.specialChar.includes(h))if(s.activeArgument){!((u=(c=s.activeArgument)==null?void 0:c.name)!=null&&u.length)&&h===re?s.isLongArgument=!0:s.activeArgument.name+=h;continue}else{s.activeArgument={name:O},s.isLongArgument&&(s.activeArgument.long=s.isLongArgument);continue}Oe(s,h)}return De(o,{forceProgram:t,mergeArgs:r,mergeArgsBy:i})}function Re(a){var e,t,r;return((e=a.value)==null?void 0:e.type)==="any"&&!a.name&&((t=a.value)==null?void 0:t.raw)&&/^[a-zA-Z]+$/.test((r=a.value)==null?void 0:r.raw)||!1}function Le(a){var e;return((e=a.value)==null?void 0:e.raw)==="+"}function ve(a,e=/^[+]$/){return a.reduce((t,r)=>{var o,c,u,h,l,P;const i=(c=(o=t[t.length-1])==null?void 0:o.value)==null?void 0:c.raw,s=i&&i[String(i).length-1];if(typeof e=="string"&&(String((u=r.value)==null?void 0:u.raw)===e||String(s)===e)||e instanceof RegExp&&(e.test(String((h=r.value)==null?void 0:h.raw))||e.test(String(s)))){const v=t[t.length-1].value;v&&v.raw&&typeof v.value=="string"&&(v.raw+=(l=r.value)==null?void 0:l.raw,v.value+=((P=r.value)==null?void 0:P.value)||"",v.type="any")}else t.push(r);return t},Array())}function Ve(a,e){const t=[];return a&&t.push(a),t.push(...e.map(r=>{var i,s;if(r.plain)return((i=r.value)==null?void 0:i.raw)||r.name||O;{const o=r.long?"--":"-",c=r.name||O,u=((s=r.value)==null?void 0:s.raw)||O,h=r.value?ge:"";return`${o}${c}${h}${u}`}})),t}function De(a,{forceProgram:e,mergeArgs:t,mergeArgsBy:r}={}){var h;const i=a[0],s=a[1];let o;(!s||!Le(s))&&i&&(Re(i)||e)&&(a=a.filter(l=>l!==i),o=(h=i.value)==null?void 0:h.raw);let c=a;t&&(c=ve(a,r));const u=Ve(o,c);return{program:o,args:c,rawArgs:u}}const Ce="\\",O="",de=" ",re="-",ge="=",Ee='"',xe="'";function Be(a){return a===Ce}function Oe(a,e){Be(e)?a.escaped=!0:(!a.escaped&&!a.isBufferValue&&!_(a,e)?(a.isBufferWrite=!0,a.isBufferValue=!0,(e===xe||e===Ee)&&!a.isClamp&&(a.currentTick=e,a.isBufferString=!0),a.isBufferString=e===a.currentTick,a.rawBuffer=void 0,a.activeArgument=a.activeArgument||{value:void 0,plain:!0}):e===a.currentTick&&a.isBufferString&&!a.escaped&&!a.isClamp&&(a.isBufferWrite=!1),(e!==a.currentTick||a.isClamp||a.escaped&&e===a.currentTick)&&((!a.isBufferWrite&&a.isBufferString||a.isBufferWrite&&!a.isBufferString)&&!a.isClamp&&a.specialChar.includes(e)&&!a.additionSpecial?(a.rawCommand=" "+e+" "+a.rawCommand,a.additionSpecial=!0):(a.additionSpecial=!1,a.rawBuffer=(a.rawBuffer||"")+e)),a.escaped=!1),a.isBufferWrite&&(e==="("?a.isClamp=!0:e===")"&&(a.isClamp=!1)),a.lastChar=e}function ke(a){var e,t,r;return a.plain&&!a.name&&((e=a.value)==null?void 0:e.type)==="any"&&(((t=a.value)==null?void 0:t.raw)===void 0||((r=a.value)==null?void 0:r.raw)===O)}function Fe(a,e){a.activeArgument&&(a.isLongArgument&&(a.activeArgument.long=a.isLongArgument),ke(a.activeArgument)||e.push(a.activeArgument)),a.activeArgument=void 0,a.isLongArgument=!1,a.isKeyWordArgument=!1}function Me(a){const e=a.rawBuffer||O;if(a.isBufferString)a.activeArgument.value={type:"string",value:a.rawBuffer,raw:`${a.currentTick}${a.rawBuffer||""}${a.currentTick}`};else{let t="any",r=e;/^[+-]?\d+$/.test(e)?(t="integer",r=Math.round(Number(e))):/^[+-]?(?:\d+\.?\d*|\.\d+)$/.test(e)?(t="double",r=Number(e)):/^true|false$/.test(e)?(t="boolean",r=e==="true"):/^[a-zA-Z$]+$/.test(e)?(t="any",r=String(e).replace(/ /g,O)):/^[\d+\-*./a-zA-Z$]+$/.test(e)&&(t="term",r=String(e).replace(/ /g,O)),a.activeArgument.value={type:t,value:r,raw:a.rawBuffer}}a.rawBuffer=void 0,a.isBufferValue=!1,a.isBufferString=!1}var H;const N=class N{constructor(e){m(this,H);w(this,H,e)}async parse(e){const t=k(e,{forceProgram:!0}),r=await this.getArguments(t);return{origin:e,unresolved:Ge(t),args:r.args,kwargs:r.kwargs,command:t.program||"",commandValue:e}}async getArguments(e){return{args:await Promise.all(e.args.filter(t=>t.plain).map(t=>{if(t.value)return this.parseValue(t.value)})),kwargs:Object.fromEntries(await Promise.all(e.args.filter(t=>!t.plain).map(async t=>[pe(t.name||""),t.value&&await this.parseValue(t.value)||void 0])))}}parseValue({value:e,type:t}){return typeof e=="string"&&[ae.ANY,ae.TERM].includes(t)?n(this,H).parse(e.replace(/ *([a-zA-Z_-]+) */,"$1")):Promise.resolve(e)}static extractStrings(e){let t=!1,r=0;const i=[];let s=!1;for(let c=e.length-1;c>=0;c--){const u=e[Number(c)],h=e[c-1];!s&&u==='"'&&h!=="\\"?t?(t=!1,i.push(e.slice(c,r+1))):(s=!1,t=!0,r=c):(!t&&s||s)&&u==="'"&&h!=="\\"&&(t?(s=!1,t=!1,i.push(e.slice(c,r+1))):(s=!0,t=!0,r=c))}if(t)throw new Error("can't extract values; "+e);return{result:i.reduce((c,u,h)=>c.replace(u,N.resolveKey(h)),e),values:i}}static extractValues(e,t=" "){let r=!1,i=0;const s=[];let o=!1;for(let u=e.length-1;u>=0;u--){const h=e[Number(u)],l=e[u-1];!o&&h==='"'&&l!=="\\"?r?(r=!1,s.push(e.slice(u,i+1))):(o=!1,r=!0,i=u):(!r&&o||o)&&h==="'"&&l!=="\\"&&(r?(o=!1,r=!1,s.push(e.slice(u,i+1))):(o=!0,r=!0,i=u))}if(r)throw new Error("can't extract values; "+e);return s.forEach((u,h)=>{e=e.replace(u,N.resolveKey(h))}),{params:e.split(t).filter(u=>u),values:s}}static resolveKey(e){return`$$$$$$${e}`}static resolveValues({params:e,values:t}){return e.map(r=>N.resolveValue(r,t))}static valueUnresolved(e){return typeof e=="string"&&N.REGEX_VALUE_RESOLVE.test(e)}static resolveValue(e,t){var i;let r=e;if(N.valueUnresolved(e)){if(r=(i=String(e).match(/[$]{3}(\d+)/g))==null?void 0:i.reduce((s,o)=>s.replace(o,t[Number(o.replace(N.REGEX_VALUE_RESOLVE,"$1"))]),String(e)),/[\w]+[$%]?[ ]*\(/.test(r||""))return r;if(typeof r=="string"){if(r==="undefined")return;if(Ue(r))return Number(r);if(!r.startsWith('"'))return r}}return r}};H=new WeakMap,p(N,"REGEX_VALUE_RESOLVE",/[$]{3}(\d+)/),p(N,"REGEX_COMMAND_REPLACE",/^([a-zA-Z]+[a-zA-Z0-9_]+) (.*)$/),p(N,"REGEX_PARAM_KWARG",/^[-]{0,2}([\\-\w]+)=(.*)$/),p(N,"REGEX_PARAM_ARG",/^[-]{1,2}([\\-\w]+)$/);let T=N;function Ue(a){return!isNaN(Number(a))}function Ge(a){return{args:a.args.filter(e=>e.plain).map(e=>{var t;return((t=e.value)==null?void 0:t.raw)||""}),kwargs:Object.fromEntries(a.args.filter(e=>!e.plain).map(e=>{var t;return[pe(e.name||""),((t=e.value)==null?void 0:t.raw)||""]}))}}var U;class we{constructor(e,t,r,i){p(this,"name");m(this,U);p(this,"global",!1);p(this,"readonly",!1);this.name=e,w(this,U,t),this.global=r||this.global,this.readonly=i||this.readonly}get value(){return n(this,U)}set value(e){this.readonly||w(this,U,e)}}U=new WeakMap;class We extends we{constructor(e,t,r=!1){super(e,t,r,!0)}async execute(...e){if(typeof this.value=="function")return this.value(...e)}}class ie extends we{}var g,x,S;class ne{constructor(){m(this,g,new Map);m(this,x,new Map);m(this,S,[])}reset(){this.resetPrefixStack(),n(this,g).clear(),n(this,x).clear()}resetPrefixStack(){w(this,S,[])}get prefixStack(){return n(this,S)}get currentPrefixStack(){return n(this,S)[n(this,S).length-1]}has(e){var t;return e=e.replace(/(.*[^ ])[ ]+$/,"$1"),e=e.replace(/[$%]$/,""),(!n(this,g).get(e)||n(this,g).get(e)&&!((t=n(this,g).get(e))!=null&&t.global))&&(e=this.prepareName(e)),n(this,g).has(e)}add(e,t,r=!1,i=!1){e=e.replace(/(.*[^ ])[ ]+$/,"$1"),/\$$/.test(e)?t===void 0&&(t=""):/\\%$/.test(e)&&t===void 0&&(t=0),e=e.replace(/[$%]$/,""),e=this.prepareName(e),this.has(e)||n(this,g).set(e,new ie(e,t,r,i))}get(e){var i;e=e.replace(/(.*[^ ])[ ]+$/,"$1");const t=e;e=e.replace(/[$%]$/,""),(!n(this,g).get(e)||n(this,g).get(e)&&!((i=n(this,g).get(e))!=null&&i.global))&&(e=this.prepareName(e));const r=n(this,g).get(e);if(r){let s=r.value;return s&&typeof s=="string"&&(/\$$/.test(t)?s=String(s):/\\%$/.test(t)||/^\d+$/.test(s)?s=parseInt(s):/^[\d.]+$/.test(s)&&(s=parseFloat(s))),s}}set(e,t,r=!1,i=!1){if(e=e.replace(/(.*[^ ])[ ]+$/,"$1"),typeof t=="string"&&(/[$]$/.test(e)?t===void 0?t="":t=String(t):/[%]$/.test(e)&&(t===void 0?t=0:t=parseInt(t))),e=e.replace(/[$%]$/,""),e=this.prepareName(e),this.has(e)){const s=n(this,g).get(e);s instanceof ie&&s&&(s.value=t)}else this.add(e,t,r,i)}addSub(e,t){e=this.prepareName(e,!1),this.has(e)||n(this,x).set(e,new We(e,t))}async executeSub(e,t=[],r=!1){t=t||[],e=this.prepareName(e,!1),n(this,S).push({name:`${Math.round(Math.random()*1e4)}`,global:r});const i=n(this,x).get(e);return i==null?void 0:i.execute(...t).then(s=>(n(this,g).forEach(o=>{RegExp(`[$]{3}${n(this,S)[n(this,S).length-1].name}$`).test(o.name)&&n(this,g).delete(o.name)}),n(this,S).pop(),s))}hasSub(e){return e=this.prepareName(e,!1),n(this,x).has(e)}prepareName(e,t=!0){return typeof e=="string"&&(e=e.replace(/ /g,"")),t&&n(this,S).length&&!/[$]{3}/.test(e)&&(e=`${e}$$$${n(this,S)[n(this,S).length-1].name}`),e}get dims(){return n(this,g)}get subs(){return n(this,x)}}g=new WeakMap,x=new WeakMap,S=new WeakMap;var F,j,d,I,D,z,K,b,Z,M,C,$,B,R,L,fe;let Xe=(fe=class{constructor(e,t,r,i,s,o){p(this,"debug",!1);m(this,F);m(this,j);m(this,d);m(this,I);m(this,D);m(this,z,9999999999);m(this,K,0);m(this,b);m(this,Z,[]);m(this,M,0);m(this,C,[]);m(this,$,-1);m(this,B,[]);m(this,R,[]);m(this,L,-1);w(this,D,e),w(this,I,t||(()=>Promise.resolve(void 0))),w(this,d,r||new ne),w(this,F,i),w(this,j,s),this.debug=o!==void 0?o:this.debug}get memory(){return n(this,d)}get lines(){return n(this,D)}parse(e){var r;e=e||Array().concat(n(this,D));const t=(r=e.shift())==null?void 0:r.trim();return new Promise(i=>{if(n(this,b)&&t!=="END SUB"){t&&n(this,b).lines.push(t),i(void 0);return}if(n(this,z)>0&&n(this,K)>n(this,z))throw new Error("BASIC INTERPRETER OVERFLOW");if(y(this,K)._++,n(this,L)>=0){const s=n(this,R)[n(this,L)];if(s){if(n(this,R).forEach(o=>{s.count===0&&o&&t&&o.count===0&&o.lines.push(t)}),t&&(t==="WEND"||/NEXT /.test(t)))return s.condition().then(async o=>{if(s.tmpLines=s.tmpLines||e,o){const c=s.lines;return s.count++,s&&typeof s.step=="function"&&await s.step(),c.length>0?this.parse(Array().concat(c)):(n(this,R)[n(this,L)]=!1,y(this,L)._--,n(this,R).pop(),null)}else return n(this,R)[n(this,L)]=!1,y(this,L)._--,n(this,R).pop(),null}).then(i);i(void 0)}else i(void 0)}else i(void 0)}).then(()=>{if(!n(this,b)&&n(this,$)>=-1&&(n(this,B)[n(this,$)]!==void 0&&n(this,C)[n(this,$)]===void 0&&n(this,C).push(!n(this,B)[n(this,$)]),t==="ELSE"&&n(this,M)<1&&(n(this,C)[n(this,$)]=!n(this,C)[n(this,$)])),n(this,C)[n(this,$)])t&&/^IF (\((.*)\)|(.*)) THEN$/.test(t)&&y(this,M)._++;else return this.parseLine(t,e);return null}).then(()=>(n(this,$)>-1&&(t==="ENDIF"||t==="END IF")&&(n(this,M)<1?(y(this,$)._--,n(this,B).pop(),n(this,C).pop()):y(this,M)._--),e.length?this.parse(e):n(this,Z)))}parseLine(e,t){return new Promise((r,i)=>{if(e=(e||"").replace(/^[ \t]+/g,""),/^ *[#/]+/.test(e)){r(void 0);return}if(/^GOTO +([\w\d]+)$/.test(e)){const s=e.match(/^GOTO +([\w\d]+)$/)||[];this.commandGoto(t,s[1]),e=""}if(/^SUB (.*) STATIC$/.test(e)){const s=e.match(/^SUB (.*) STATIC$/)||[];return this.commandSubStatic(s[1]).then(r)}else{if(e==="END SUB")return this.commandEndSub().then(r);if(n(this,b)){r(void 0);return}}if(/^IF (\((.*)\)|(.*)) THEN$/.test(e)){const s=e.match(/^IF (\((.*)\)|(.*)) THEN$/)||[],o=s[3]||s[2];return this.commandIfThen(o).then(r)}else if(e==="ELSE"||e==="ENDIF"||e==="END IF"){r(void 0);return}if(/^WHILE (.*)$/.test(e)){const s=e.match(/^WHILE (.*)$/)||[];return this.commandWhile(s[1]).then(r)}else if(e==="WEND"){r(void 0);return}if(/^FOR (.*)$/.test(e)){const s=e.match(/^FOR (.*)$/)||[];return this.commandFor(s[1]).then(r)}else if(e.startsWith("NEXT ")){r(void 0);return}if(/^([\w\d]+):$/.test(e)){r(void 0);return}if(/^DIM( SHARED)? +(.*)$/.test(e)){const s=e.match(/^DIM( SHARED)? +(.*)$/)||[];return this.commandDimShared(s[2],!!s[1]).then(r)}if(/^LET +([\w,$%]+)(\((.*)\))? *= *(.*)$/.test(e)){const s=e.match(/^LET +([\w,$%]+)(\((.*)\))? *= *(.*)$/)||[];return this.commandLet(s[1],s[4],s[3]).then(()=>r(void 0))}if(/^READ +([\w, $%]+)$/.test(e)){const s=e.match(/^READ +([\w, $%]+)$/)||[];return this.commandRead(s[1]).then(r)}if(/^END[ ]*$/.test(e))return this.commandEnd().then(r);if(/^(PAUSE|SLEEP) +(.+)/.test(e)){const o=(e.match(/^(PAUSE|SLEEP) +(.+)/)||[])[2];return this.commandPause(o).then(r)}if(/^CALL *(.*)/.test(e)){const s=e.match(/^CALL *(.*)/)||[];return this.commandCall(s[1],t).then(r)}if(/^EXECUTE *(FILE|EVAL) *(.*)/.test(e)){const s=e.match(/^EXECUTE *(FILE|EVAL) *(.*)/)||[];return this.commandExecute(s[1],s[2]).then(r).catch(i)}if(/^PRINT +USING +.*$/.test(e)){const s=e.match(/^PRINT +USING +(.*)$/)||[];return this.commandPrintUsing(s[1]).then(r)}if(/^PRINT +(.*)$/.test(e)){const s=e.match(/^PRINT +(.*)$/)||[];return this.commandPrint(s[1]).then(r)}if(/^DATA +(.*)$/.test(e)){const s=e.match(/^DATA +(.*)$/)||[];return this.commandDataVar(s[1]).then(r)}n(this,I).call(this,e,{show:!0}).then(s=>{s!==void 0&&n(this,Z).push(s)}).then(r).catch(i)})}async setReadStack(e,t){let r=await this.parseValue(t,!0);return typeof r=="string"&&V(r)&&(r=parseFloat(r)),n(this,d).set(e,r,!0)}async addDataStack(e){let t=await this.parseValue(e,!0);return typeof t=="string"&&V(t)&&(t=parseFloat(t)),n(this,F).push(t)}async setStack({name:e,value:t,index:r,global:i}){let s=await this.parseValue(t,!0);if(typeof s=="string"&&V(s)&&(s=parseFloat(s)),r!==void 0){r=Number(await this.parseValue(r,!0));const o=n(this,d).get(e);if(typeof o=="object")return o[r-1]=s,s;throw new Error(`Index ${r} out of range`)}else return n(this,d).set(e,s,i)}async setGotoMarkStack(e,t){n(this,j).set(e,await this.parseValue(t,!0))}async parseValue(e,t=!0,r=!1){if(e===void 0)return e;if(Array.isArray(e))return e;if(typeof e=="boolean")return e;if(typeof e=="number")return Number(e);if(typeof e=="string"){if(/^ *(true|false|TRUE|FALSE) *$/.test(e))return e.toLowerCase()==="true";if(/^[\d]+$/.test(e.trim())||/^ *([\\-]?[\d.]+(e[-+]?\d+)?) *$/.test(e.trim()))return parseFloat(e);if(/^ *@"((.|\n)*)" *$/.test(e.trim()))return e.replace(/^ *@"((.|\n)*)" *$/,'"$1"');if(/^"((\\"|[^"])+)"$/.test(e.trim()))return e.trim().replace(/^"((\\"|[^"])+)"$/,'"$1"');if(/^[^"]?(.+)[^"]? *$/.test(e.replace(/ /g,""))){if(e=e.replace(/^ */g,""),n(this,d).has(e.replace(/ /g,"")))return e=e.replace(/ /g,""),this.parseValue(n(this,d).get(e),!0);if(r)throw new Error(`Value processing continues: ${e.slice(0,20)}…'`);return n(this,I).call(this,e,{message:t?void 0:e})}}}async executeCondition(e,t,r){const i=await this.parseValue(e,!0),s=await this.parseValue(r,!0);return/^[=]?==$/.test(t)?i===s:t==="<>"?i!==s:/^([<>][=]|[<>])?$/.test(t)?_e(i,t,s):/^!=[=]?$/.test(t)?i!==s:!1}commandIfThen(e){const t=e.match(/([^<>]*) *(<>|<=|>=|<|>|[=!]{2,3}) *([^<>].*)/);return t?this.executeCondition(t[1],t[2],t[3]).then(r=>(n(this,B).push(r),y(this,$)._++,r)):this.parseValue(e[1],!0).then(r=>{let i=r;return r instanceof ie&&(i=r.value),n(this,B).push(!!i),y(this,$)._++,i})}commandWhile(e){const t=e.match(/([^<>]*) *(<>|<=|>=|<|>|[=!]{2,3}) *([^<>].*)/);return t?this.executeCondition(t[1],t[2],t[3]).then(r=>{if(r)return n(this,R).push({count:0,lines:[],condition:()=>this.executeCondition(t[1],t[2],t[3])}),y(this,L)._++,r}):Promise.resolve(void 0)}async commandFor(e){const t=e.match(/(.*) *= *(.*) +TO +(.*) +STEP[ ](.*)/)||e.match(/(.*) *= *(.*) +TO +(.*)/);if(t){const r=await this.parseValue(t[2],!0),i=await this.parseValue(t[3],!0);n(this,d).set(t[1],r),y(this,L)._++;const s=async(o=!0)=>{let c=1;return t[4]&&(c=await this.parseValue(t[4],!0)),o&&n(this,d).set(t[1],Number(n(this,d).get(t[1]))+c),c};return n(this,R).push({step:s,count:0,lines:[],condition:async()=>{const o=await s(!1);return o===0?!1:this.executeCondition(`(${t[1]}  )`,o<0?">":"<",String(i))}})}}commandSubStatic(e){const t=e.match(/^([\w,$%]+)(\((.*)\))?$/)||[],r=t[1],i=T.resolveValues(T.extractValues(t[3]||"",","));return w(this,b,{name:r,lines:[],args:i}),Promise.resolve(void 0)}commandEndSub(){if(n(this,b)){const e=n(this,b).lines,t=n(this,b).args;n(this,d).addSub(n(this,b).name,async(...r)=>{(await Promise.all(t.map((s,o)=>this.parseValue(r[Number(o)]).then(c=>({arg:s,value:c}))))).forEach(({arg:s,value:o})=>{s&&n(this,d).add(String(s),o)}),await this.parse(Array().concat(e))}),w(this,b,void 0)}else throw new Error("has no active SUB");return Promise.resolve(void 0)}commandGoto(e,t){return e.splice(0,e.length),this.parse(n(this,D).slice(n(this,D).indexOf(`${t}:`),n(this,D).length))}commandDimShared(e,t){return T.resolveValues(T.extractValues(e,",")).reduce((i,s)=>{const o=String(s||"").match(/^([\w, $%]+)?(\((.*)\))?$/)||[];return n(this,d).has(o[1])||(o[3]&&(i=i.then(()=>this.parseValue(o[3],!0))),i=i.then(c=>(this.setStack({name:o[1],value:c?Array(c):void 0,global:t}),c))),i},Promise.resolve(void 0))}commandLet(e,t,r){if(n(this,d).has(e))return this.setStack({name:e,value:t,index:r});throw new Error(`Variable ${e} not defined`)}async commandPrintUsing(e){const t=k(e,{mergeArgs:!0,mergeArgsBy:/^[+,]$/}).rawArgs,r=k(t[2],{mergeArgs:!0}).rawArgs.filter(o=>o!==",").map(o=>this.parseValue(o)),i=await Promise.all(r);let s=E(t[0]);for(;s.includes("#");){const o=i.shift(),c=s.match(/(#+\.#+)|(#+)/);if(c&&/(#+\.#+)/.test(c[0])){const[u,h]=c[0].split("."),[l,P]=String(o).split("."),v=he(String(l||"").slice(0,u.length),u.length,!0," ")+"."+he(String(P||"").slice(0,h.length),h.length,!1,"0");s=s.replace(/(#+\.#+)/,E(String(v)))}else s=s.replace(/(#+|#+\.#+)/,E(String(o)))}return n(this,I).call(this,null,{message:`"${E(s)}"`})}commandDataVar(e){if(n(this,F).length===0)return Promise.all(e.split(",").map(t=>this.addDataStack(t)));throw new Error("DATA has already been declared")}async commandPrint(e){if(/^((".*"|[^"]*);([^;]*))$/.test(e)){const t=e.match(/(.*);(.*)$/)||[],r=await this.parseValue(t[1],!0),{rawArgs:i}=k(String(t[2]),{mergeArgs:!0});let s=await Promise.all(i.map(c=>this.parseValue(c,!0)));s=s.map(c=>E(c));const o=s.map(c=>`${E(r)}${c}`).join(" ");return n(this,I).call(this,null,{message:se(o)||V(o)?o:`"${o}"`})}else{let t=await this.parseValue(e);const{rawArgs:r}=k(String(t),{mergeArgs:!0});let i=await Promise.all(r.map(s=>this.parseValue(s,!0)));return i=i.map(s=>E(s)),i.length>1?t=i.join(""):t=i[0],n(this,I).call(this,null,{message:se(t)||V(t)?t:`"${t}"`})}}commandEnd(){return Promise.resolve(void 0)}async commandPause(e){const t=Number(await this.parseValue(e));return new Promise(r=>window.setTimeout(()=>{r(void 0)},t))}commandRead(e){const t=e.split(",");return Promise.all(t.map(r=>{const i=n(this,F).shift();return this.setReadStack(r,i),Promise.resolve(void 0)}))}commandCall(e,t){const i=(e.match(/([^(]+)\(.*\)/)||[])[1];if(n(this,d).hasSub(i))return this.parseLine(e,t);throw new Error(`SUB ${i} NOT FOUND`)}async commandExecute(e,t){if(!n(this,I))throw new Error("No callback available for readfile");let r;switch(e){case"FILE":if(r=await n(this,I).call(this,`readfile ${t}`,{show:!1}),r&&typeof r=="object"&&"content"in r)return n(this,I).call(this,r.content,{show:!0});throw new Error("File Content is empty");case"EVAL":return this.parseValue(t,!1)}}},F=new WeakMap,j=new WeakMap,d=new WeakMap,I=new WeakMap,D=new WeakMap,z=new WeakMap,K=new WeakMap,b=new WeakMap,Z=new WeakMap,M=new WeakMap,C=new WeakMap,$=new WeakMap,B=new WeakMap,R=new WeakMap,L=new WeakMap,fe);function _e(a,e,t){switch(a=String(a),t=String(t),(e.match(/^([<>][=]|[<>])$/)||[])[1]){case"<":return parseFloat(a)<parseFloat(t);case">":return parseFloat(a)>parseFloat(t);case"<=":return parseFloat(a)<=parseFloat(t);case">=":return parseFloat(a)>=parseFloat(t);default:return null}}var G,W,J,ee;class He{constructor(e,t){m(this,G);m(this,W);m(this,J,new Map);m(this,ee,[]);w(this,W,t),w(this,G,e)}get callback(){return n(this,W)}get memory(){return n(this,G)}async parse(e,t,r){if(e.length===0)return;e.length>1&&await this.readData(e);const i=[];return new Xe(e,async(o,c)=>{c={...c,...r};const u=await(t||n(this,W)||(()=>{}))(o,c);return c.show&&u!==void 0&&i.push(u),u},n(this,G),n(this,ee),n(this,J)).parse().then(()=>i)}readData(e){const t=e.find(r=>/^[ ]*DATA[ +]/.test(r));if(t){const r=e.splice(e.indexOf(t),1);return this.parse(r)}return Promise.resolve(void 0)}}G=new WeakMap,W=new WeakMap,J=new WeakMap,ee=new WeakMap;function A(...a){if(a.includes(void 0))throw new Error("invalid arguments")}const f={};try{f.brackets=/([^\w$%]?)\(([^\\(\\)]+)\)/,f.brackets_start=/^\((.*)\)$/,f.multiply=new RegExp("[^\\d$\\-\\w]?(?<a>([+-]?[\\w.]+e\\+\\d+)|([+-]?[\\w$%.]+)|(^[+-]?[\\w$%.]+)|([\\w$%.]+)|([$]{3}\\d+))[ ]*(?<operator>[\\^*%\\/]|MOD|XOR|AND|OR|<<|>>|>>>)[ ]*(?<b>([-]?[\\w.]+e\\+\\d+)|([-]?[\\w$%.]+)|(^[+-]?[\\w$%.]+)|([\\w$%.]+)|([$]{3}\\d+))"),f.add_subtract=/([+-]?[\w.]+e\+\d+|[+-]?[\w$%.]+|[$]{3}\d+)[ ]*([+-])[ ]*([+-]?[\w.]+e\+\d+|[+-]?[\w$%.]+|[$]{3}\d+)/,f.function=/([\w]+[a-zA-Z0-9_.]+[$%]?)[ ]*\(([^\\(\\)]*)\)/,f.function_start=/^([\w]+[a-zA-Z0-9_.]+[$%]?)[ ]*\(([^\\(\\)]*)\)/,f.variable=/^([\w]+[a-zA-Z0-9_.]?[$%]?)/,f.number=/^([+-]?[\d.]+e\+\d+|[+-]?[\d.])+($|$)/}catch(a){console.error(a)}class je{constructor(e,t){p(this,"debug",!1);p(this,"memory");this.memory=this.createMemory(e),this.debug=t!==void 0?t:this.debug}createMemory(e){const t=e||new ne;return t.addSub("RND",()=>Promise.resolve(Math.random())),t.addSub("PI",()=>Promise.resolve(Math.PI)),t.addSub("POW",(r,i)=>{if(A(r,i),typeof r=="string")throw new Error("Parameter is not a number");if(typeof i=="string")throw new Error("Parameter is not B number");return Promise.resolve(r**(i||2))}),t.addSub("SQRT",r=>{if(A(r),typeof r=="string")throw new Error("Parameter is not a number");return Promise.resolve(Math.sqrt(r))}),t.addSub("INT",async r=>(A(r),await parseInt(E(String(r))))),t.addSub("SPC",r=>{if(A(r),typeof r=="string")throw new Error("Parameter is not a number");return Promise.resolve(`"${le(r," ")}"`)}),t.addSub("LEN",r=>(A(r),Promise.resolve(E(String(r)).length))),t.addSub("ASC",r=>(A(r),Promise.resolve(String(E(r)).charCodeAt(0)))),t.addSub("CHR$",r=>{if(A(r),typeof r=="string")throw new Error("Parameter is not a number");return Promise.resolve(Q(String.fromCharCode(r)))}),t.addSub("LEFT$",(r,i)=>{if(A(r,i),typeof i=="string")throw new Error("Parameter is not B number");return Promise.resolve(`"${Ae(E(r),i)}"`)}),t.addSub("RIGHT$",(r,i)=>{if(A(r,i),typeof i=="string")throw new Error("Parameter is not B number");return Promise.resolve(Q(Ne(String(E(r)),i)))}),t.addSub("STRING$",(r,i)=>{if(A(r,i),typeof r=="string")throw new Error("Parameter is not a number");return Promise.resolve(Q(le(r,String(E(i)))))}),t.addSub("TIME%",()=>Promise.resolve(Date.now())),t.addSub("HEX_ENC$",r=>(A(r),Promise.resolve(Q(Number(E(r)).toString(16))))),t.addSub("HEX_DEC$",r=>(A(r),r=parseInt(String(E(r)),16),Promise.resolve(r))),t}async parse(e){const r=await new Ke(this).parse(e);return this.debug&&console.debug("Result:",typeof r,r),r}validInput(e){return e&&/[/*\-+^()]?/.test(e)}}const ze=5e3;class Ke{constructor(e,{debug:t}={}){p(this,"debug",!1);p(this,"parser");p(this,"parsedValues",[]);p(this,"timeout",0);this.parser=e,this.debug=t!==void 0?t:this.debug}async parse(e){if(this.debug&&console.debug("PARSE ".padEnd(20,"-")),this.timeout>ze)throw new Error(`Can't parse ${e}`);this.timeout++;const{result:t,values:r}=T.extractStrings(String(e));let i=k(t).rawArgs;this.parsedValues=this.parsedValues.concat(r),i=i.map(u=>/^MOD|XOR|AND|OR$/.test(u)?` ${u} `:u);let s=i.join("");V(s)?s=Number(s):se(s)&&(s=!!s);const o=s,c=await this.action(s);if(this.debug&&console.debug("action:",typeof c,c),c!==void 0){let u;return typeof c=="string"&&c!==o&&!/^".*"$/.test(String(c))?(u=await this.parse(c),this.debug&&console.debug("parse:",typeof u,u),u):(u=await this.resolveValue(c),this.debug&&console.debug("$v:",typeof u,u),u)}}async action(e){var t,r,i,s,o,c;if(typeof e=="string"){if((t=f.brackets_start)!=null&&t.test(e)){const u=e.match(f.brackets_start);if(u){const[h,l]=u;e=e.replace(h,l)}else throw new Error("Invalid expression")}if((r=f.function)!=null&&r.test(e)){const u=e.match(f.function);if(u){const[h,l,P,v]=u,Y=l||v;let te=k(P||"",{separator:","}).rawArgs;const oe=P.includes(",")&&te.join("")!==P;oe&&(te=P.split(","));let X=await Promise.all(te.map(Se=>this.parse(Se)));if(X=oe?X:[await this.parse(X.join(""))],this.parser.memory.has(Y))return e.replace(h,(i=this.parser.memory.get(Y))==null?void 0:i[Number(X[0])-1]);if(this.parser.memory.hasSub(Y))return e.replace(h,this.cacheValue(await this.parser.memory.executeSub(Y,X)))}}if((s=f.brackets)!=null&&s.test(e)){const u=e.match(f.brackets);if(u){const[h,l,P]=u;return e.replace(h,l+await this.parse(P))}else throw new Error("Invalid expression")}if((o=f.multiply)!=null&&o.test(e))return this.operation(e,f.multiply);if((c=f.add_subtract)!=null&&c.test(e))return this.operation(e,f.add_subtract)}return this.resolveValue(e)}async operation(e,t){const r=e.match(t);if(r){let i,s,o;const c=r[0];"groups"in r&&r.groups?(i=r.groups.a,s=r.groups.b,o=r.groups.operator):(i=r[1],o=r[2],s=r[3]);let u=e,h=await this.parse(i);V(h)||(h=E(h));let l=await this.parse(s);switch(V(l)||(l=E(l)),this.debug&&console.debug({valueA:h,valueB:l}),h=h,l=l,o){case"+":u=h+l;break;case"-":u=h-l;break;case"*":u=h*l;break;case"/":u=h/l;break;case">":u=h>l;break;case"<":u=h<l;break;case"^":u=h^l;break;case"%":u=h%l;break;case"MOD":u=h%l;break;case"AND":u=h&l;break;case"OR":u=h|l;break;case"XOR":u=h^l;break;case"<<":u=h<<l;break;case">>":u=h>>l;break;case">>>":u=h>>>l;break}return V(u)||(u=`"${u}"`),e.replace(c,c.replace(RegExp(`[${i}]{${String(i).length}}[ ]*[${o}]{${String(o).length}}[ ]*[${s}]{${String(s).length}}`),"")+this.cacheValue(u))}else throw new Error("Invalid expression")}async resolveValue(e){var t,r,i;if(typeof e!="function"&&T.valueUnresolved(e))return T.resolveValue(e,this.parsedValues);if(typeof e=="string"){if(e=e.replace(/^[ ]*([^ ].*[^ ])[ ]*$/,"$1"),(t=f.number)!=null&&t.test(e)){if(V(e))return Number(e)}else if((r=f.function_start)!=null&&r.test(String(e))){const s=e.match(f.function_start);if(s){const[,o,c]=s;if(this.parser.memory.hasSub(o))return this.parser.memory.executeSub(o,T.resolveValues(T.extractValues(c,",")));throw new Error(`can't find sub "${o}" in memory`)}else throw new Error("Invalid expression")}else if((i=f.variable)!=null&&i.test(String(e))){const s=e.replace(f.variable,"$1");if(this.parser.memory.hasSub(s))return this.parser.memory.executeSub(s);if(this.parser.memory.has(s))return this.parser.memory.get(s)}}return e}cacheValue(e){return this.parsedValues.push(e),T.resolveKey(this.parsedValues.length-1)}}const Ze=["CLS","READ max","DIM fib%(max)","LET fib(1) = 1","LET fib(2) = 2","FOR i=3 TO max","LET fib(i) = fib(i - 2) + fib(i -1)","NEXT i","FOR i=1 TO max","PRINT fib(i)","NEXT i","DATA 10","END"],Ye=["CLS","DIM w%,h%,a%","LET w%=12","LET h%=4","LET a%=w%*h%",'PRINT "With the width " + w%','PRINT " and the height " + h%','PRINT " you have the area " + a%'],Qe=["CLS","DIM r,a","LET r=5","READ pi","LET a=r*r*pi",'PRINT USING "With the radius ##.##"; r','PRINT USING "we have the area ##.##"; a',"DATA 3.14","END"],qe=["GuessTheNumber","CLS","READ max%","DIM number%, guess%, guesses%",'PRINT "The number is between 1-1000."',"LET number% = INT(RND * max%) + 1","LET guess% = 1","LET guesses% = 0","WHILE guess%<>number%",'PRINT "Guess the number"',"INPUT guess%","IF (guess%<>number%) THEN","IF (guess%>number%) THEN",'PRINT "Your guess was too high"',"ELSE",'PRINT "Your guess was too low"',"ENDIF","ENDIF","LET guesses% = guesses% + 1","WEND",'PRINT USING "You found the number in # tries"; guesses%',"DATA 1000","END"],Je=["DIM result",'PRINT "Calculate the factorial of"',"INPUT n","LET result = 1","FOR i = n TO 1 STEP -1","LET result = result * i","NEXT i",'PRINT USING "#! = #"; n, result',"END"],et=["CLS","DIM stars$",'PRINT "Enter the height of the pyramid"',"INPUT height",'LET stars$ = ""',"FOR i = 1 TO height",'LET stars$ = ""',"FOR j = 1 TO (i+i-1)",'LET stars$ = stars$ + "*"',"NEXT j","PRINT SPC(height - i) + stars","NEXT i","END"],tt=['PRINT "Step 1"','PRINT "Step 2"','PRINT "Step 3"',"GOTO ignore",'PRINT "Step 4"',"ignore:",'PRINT "Step 5"'],rt=["DIM A, B","LET A = 2000",'LET B = "Hello World"','PRINT USING "A: #"; A','PRINT USING "B: #"; B'],st=["DIM A, B","LET A = 1","LET B = 2","IF A == B THEN",'PRINT "true"',"ELSE",'PRINT "false"',"END","IF (A < B) THEN",'PRINT "true"',"END"],at=["DIM i%","FOR i% = 1 TO 5",'PRINT USING "For Number #"; i%',"NEXT i%"],it=["DIM i%","LET i%=0","WHILE i% < 5",'PRINT USING "While Number #"; i%',"LET i% = i% + 1","WEND"],nt=["DIM duration","LET duration = 2500",'PRINT USING "Start with Pause #ms"; duration',"PAUSE duration",'PRINT "End Pause"','PRINT USING "Start with Sleep #ms"; duration',"PAUSE duration",'PRINT "End Sleep"'],ot={Fibonacci:Ze,Area:Ye,Circle:Qe,"Your Name":["CLS",'PRINT "What is your name?"',"INPUT n$",'PRINT "What is your shoe size?"',"INPUT size",'PRINT "Hello "; n$','PRINT USING "your shoe size is ##.##"; size',"END"],GuessTheNumber:qe,Factorial:Je,Pyramid:et,"Bubble Sort":["CLS","READ max","DIM SHARED numbers(max)","SUB CreateList(max) STATIC","FOR i=1 TO max","LET numbers(i) = INT(RND * 100)","NEXT i","END SUB","SUB PrintList(max) STATIC","FOR i=1 TO max","PRINT numbers(i)","NEXT i","END SUB","SUB SwapValues(i%, j%) STATIC","LET numbers(i%) = numbers(i%) XOR numbers(j%)","LET numbers(j%) = numbers(i%) XOR numbers(j%)","LET numbers(i%) = numbers(i%) XOR numbers(j%)","END SUB","SUB Sort(max) STATIC","FOR i%=1 TO (max - 1)","FOR j%=i% TO max","IF numbers(i%)>numbers(j%) THEN","CALL SwapValues(i%, j%)","END IF","NEXT j%","NEXT i%","END SUB","CreateList(max)","Sort(max)","PrintList(max)","DATA 10","END"],Goto:tt,Vars:rt,If:st,For:at,"For Step":["CLS","FOR i% = 0 TO 6 STEP 2",'PRINT "For Step Number #"; i%',"NEXT i%"],While:it,Pause:nt},ut=Pe(({module:a,core:e})=>[{name:["basic"],args:[new me({index:0,name:"path",description:"Path to basic script"})],async action({path:t},r){var s;if(!t)throw Ie.get("bad_args");const i=await((s=e.modules.files)==null?void 0:s.fileSystem.get(t));if(typeof(i==null?void 0:i.data)=="object"){const o=i.data;if(o.type==="basic"&&Array.isArray(o.content))return a.parseBasic(o.content,void 0,{logger:r.logger})}else throw new TypeError(`Can't read file ${t}`)}},{name:["basicExamples"],args:[new me({index:0,name:"name",description:"Name from example"})],action({name:t}){return a.parseBasic(ot[String(t)])}}]);class bt extends Te{constructor({core:t}){super({name:"Parser",commands:r=>[...ut(r)],core:t});p(this,"basicInterpreter");p(this,"memory",q(new ne));p(this,"mathParser",q(new je(this.memory)));p(this,"commandParser",q(new T(this.mathParser)));this.basicInterpreter=q(new He(this.memory,t.executeCommand.bind(t)))}parse(t,r,i){return this.basicInterpreter.parse(t,r,i)}parseBasic(t,r,i={}){let s=t;return Array.isArray(t)||(s=t.split(`
`)),this.basicInterpreter.parse(s,r,i)}async parseCommand(t){return this.commandParser.parse(t)}parseMath(t){return this.mathParser.parse(t)}isMathValue(t){return this.mathParser.validInput(t)}}export{bt as default};
