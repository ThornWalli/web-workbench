function v(e){return Array.isArray(e)||ArrayBuffer.isView(e)}function bt(e,t){const{x:n,y:r,z:o}=t,{x:s,y:i,z:u,w:h}=e,c=h*n+i*o-u*r,a=h*r+u*n-s*o,f=h*o+s*r-i*n,x=-s*n-i*r-u*o,S=c*h+x*-s+a*-u-f*-i,Y=a*h+x*-i+f*-s-c*-u,y=f*h+x*-u+c*-i-a*-s;return new t.constructor(S,Y,y)}const lt=Math.PI,it=Math.PI*2;function H(e){let t=e%it;return t<-lt?t+=it:t>lt&&(t-=it),t}function Dt(e){return e>-1?e<1?Math.acos(e):0:lt}function Rt(e,[t,n,r]){const[o,s,i]=e;return new e.constructor(new o.constructor(o.x*t.x+s.x*t.y+i.x*t.z,o.y*t.x+s.y*t.y+i.y*t.z,o.z*t.x+s.z*t.y+i.z*t.z),new o.constructor(o.x*n.x+s.x*n.y+i.x*n.z,o.y*n.x+s.y*n.y+i.y*n.z,o.z*n.x+s.z*n.y+i.z*n.z),new o.constructor(o.x*r.x+s.x*r.y+i.x*r.z,o.y*r.x+s.y*r.y+i.y*r.z,o.z*r.x+s.z*r.y+i.z*r.z))}function Tt(e,{x:t,y:n,z:r}){const[o,s,i]=e;return new o.constructor(o.x*t+s.x*n+i.x*r,o.y*t+s.y*n+i.y*r,o.z*t+s.z*n+i.z*r)}function Ft(e,[t,n,r]){return new e.constructor(e.dot(t),e.dot(n),e.dot(r))}function M(e){return typeof e=="number"||e?.constructor===Number}const It=e=>{try{F(e),G(e,4)}catch(t){console.error("error while hijackDOMPoint"),console.error(t)}},Q=0,mt=1,dt=2,pt=3,Z=9999999999999,K=void 0,Nt=Symbol("vector length"),tt=Symbol("get source"),qt=Symbol("checked");let p=K,q,R;const Xt=[0,1,2,6,24,120,720,5760,51840,518400,5702400,68428800,889574400,12454041600,186810624e3],yt=[];let O=-1,ct=!1;const U=[];function ut(e,t,n){p=e,O=-1,R=1;const r=t(n);if(!M(r))throw new Error(`
      your assigned progress did not not return a primitive!
      calc() does not support logical operators (|| && ==) directly

      instead of calc(() => v1 || v2);
      use        calc(() => +v1 || +v2);

      instead of calc(() => v1);
      use        calc(v1);
      `);return r}function B(e){const t=e[tt];return t?t(e).length:e[Nt]||3}function Ht(e,t){return B(e)>B(t)?e:t}function Qt(e,t){if(R+=1,t===Z)return R;if(t>=B(e))return 0;const n=e[tt];if(n)return 1*n(e)[t];if(t===Q)return 1*e.x;if(t===mt)return 1*e.y;if(t===dt)return 1*e.z;if(t===pt)return 1*e.w}function Mt(e,t,n){const r=e[tt];if(r){r(e)[t]=n;return}if(t===Q){e.x=n;return}if(t===mt){e.y=n;return}t===dt&&(e.z=n),t===pt&&(e.w=n)}function j(e,t=void 0){if(typeof e!="function")throw new Error("no function assigned");if(p!==K)throw new Error("something wrong, do you use calc() inside calc?");try{const n=typeof t>"u",r=typeof t=="function",o=!r&&!n?t:void 0,s=ut(Q,e,o);if(n&&typeof q>"u")return s;const i=q?B(q):0;if(i===Z){if(!e[qt]){const a=ut(Z,e),f=Xt[R];if(Math.abs(a-f)>Number.EPSILON)throw new Error(`
            algebraic multiplication works only in calls with *

            calc(() => v * m);
            calc(() => m * v);
            calc(() => m * m);
            calc(() => m * m * v);

            `);e[qt]=!0}let c=yt[0];for(let a=1;a<R-1;a+=1){const f=yt[a];if(!c.multiply)throw new Error(`cannot find method multiply() on ${c}`);c=c.multiply(f)}return c}let u=r?t.length:i;if(u||(u=i),u<i)throw new Error("Your assigned result Vector cant use higher space Operands than it has");const h=new Array(u);h[0]=s,o&&Mt(o,p,h[0]);for(let c=1;c<u;c+=1){const a=ut(c,e,o);h[c]=a,o&&Mt(o,p,a)}return n?new q.constructor(...h):r?t(...h):o}finally{p=K,q=void 0}}function F(e,t){const n=e.prototype;n[tt]=t;const r=n[Symbol.toPrimitive]||function(o){return o==="string"?this.toString():this.valueOf()};n[Symbol.toPrimitive]=function(o){return p===Q&&(q=q?Ht(q,this):this,yt[R-1]=this),p===K?r.call(this,o):Qt(this,p)}}function gt(e){return function(...t){if(p===Q){if(ct)return e.apply(this,t);try{ct=!0,O+=1;const n=e.apply(this,t);return U[O]=n,n}finally{ct=!1}}return p===mt||p===dt||p===pt?(O+=1,U[O]):e.apply(this,t)}}function w(e,t){const n=e.prototype,r=n[t];n[t]=gt(r)}function et(e,t){const n=e.prototype,r=Object.getOwnPropertyDescriptor(n,t);Object.defineProperty(n,t,{get:gt(function(){return r.get.call(this)})})}function G(e,t){const n=e.prototype;Object.defineProperty(n,Nt,{value:t})}function Ct(e){G(e,Z)}function nt(e){return gt(e)}typeof DOMPoint<"u"&&It(DOMPoint);function jt(e){let t="";return e&&(t=`${e}-`),t}function L(e,t,n={}){const r=jt(e);return Object.entries(t).forEach(([o,s])=>{n[`--${r}${o}`]=s}),n}const at=0,ft=1,g=Symbol("axes");function Gt(e,t,n,r){const o=Math.atan2(e,t),s=Math.atan2(n,r);return H(o-s)}function At(e){return e*e}class z{constructor(...t){typeof t[0]=="function"?j(t[0],(n,r)=>{this[g]=[n,r]}):v(t[0])?this[g]=[...t[0]]:t[0]&&M(t[0].x)?this[g]=[t[0].x||0,t[0].y||0]:this[g]=[t[0]||0,t[1]||0]}valueOf(){throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc")}normalize(){const{length:t}=this;return new this.constructor(this.x/t,this.y/t)}norm(){return this.normalize()}dot(t){return this.x*t.x+this.y*t.y}getRad(){return H(Math.atan2(this.y,this.x))}angleTo(t){return Gt(this.y,this.x,t.y,t.x)}rotate(t){const n=Math.sin(t),r=Math.cos(t),o=this.x*r-this.y*n,s=this.x*n+this.y*r;return new this.constructor(o,s)}distance(t){return Math.sqrt(At(this.x-t.x)+At(this.y-t.y))}dist(t){return this.distance(t)}toArray(){return[this.x,this.y]}calc(t){throw new Error("calc() not implemented")}clone(){throw new Error("clone() not implemented")}equals(t){return this.x===t.x&&this.y===t.y}toJSON(){return{x:this.x,y:this.y}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,n={}){return L(t,this.toJSON(),n)}get lengthSq(){return this.dot(this)}get length(){return Math.sqrt(this.lengthSq)}get lensq(){return this.lengthSq}get len(){return this.length}get x(){return this[g][at]}set x(t){throw new Error("set x() not implemented")}get y(){return this[g][ft]}set y(t){throw new Error("set y() not implemented")}get z(){throw new Error("get z() not implemented")}set z(t){throw new Error("set z() not implemented")}[Symbol.iterator](){return this[g].values()}}F(z);G(z,2);w(z,"dot");w(z,"angleTo");w(z,"distance");w(z,"toArray");w(z,"getRad");et(z,"length");et(z,"lengthSq");class rt extends z{set x(t){this[g][at]=t}set y(t){this[g][ft]=t}get x(){return this[g][at]}get y(){return this[g][ft]}calc(t){return j(t,this)}clone(){return new rt(this.x,this.y)}}class X extends z{toPoint(){return new rt(this.x,this.y)}}const Lt=nt((e,t)=>new rt(e,t)),we=(e,t)=>Lt(e,t),Yt=nt((e,t)=>new X(e,t)),zt=(e,t)=>Yt(e,t);zt(0,0);zt(0,-1);zt(-1,0);const P=0,k=1,D=2,l=Symbol("axes");function ht(e){return e*e}class m{constructor(...t){typeof t[0]=="function"?j(t[0],(n,r,o)=>{this[l]=[n,r,o]}):v(t[0])?this[l]=[...t[0]]:t[0]&&M(t[0].x)?this[l]=[t[0].x||0,t[0].y||0,t[0].z||0]:this[l]=[t[0]||0,t[1]||0,t[2]||0]}valueOf(){throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc")}normalize(){const{length:t}=this;return new this.constructor(this.x/t,this.y/t,this.z/t)}norm(){return this.normalize()}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){return new this.constructor(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}crossNormalize(t){const n=this.cross(t),{length:r}=n;return n[l][P]/=r,n[l][k]/=r,n[l][D]/=r,n}cn(t){return this.crossNormalize(t)}toAngles(){return{theta:Math.atan2(this.z,this.x),phi:Math.asin(this.y/this.length)}}angleTo(t){return H(Dt(this.dot(t)/(this.length*t.length)))}multiply(t){return t.x===void 0?this.multiplyMat3(t):t.w===void 0?this.multiplyVec3(t):bt(t,this)}multiplyMat3(t){return Ft(this,t)}multiplyVec3({x:t,y:n,z:r}){return new this.constructor(this.x*t,this.y*n,this.z*r)}distance(t){return Math.sqrt(ht(this.x-t.x)+ht(this.y-t.y)+ht(this.z-t.z))}dist(t){return this.distance(t)}toArray(){return[this.x,this.y,this.z]}swizzle(t){const n=t.split("").map(r=>this[r]);return n.length===2?new X(n[0],n[1]):new this.constructor(n[0],n[1],n[2])}calc(t){throw new Error("calc() not implemented")}clone(){throw new Error("clone() not implemented")}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}toJSON(){return{x:this.x,y:this.y,z:this.z}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,n={}){return L(t,this.toJSON(),n)}get lengthSq(){return this.dot(this)}set lengthSq(t){throw new Error("set lengthSq() not implemented")}get length(){return Math.sqrt(this.lengthSq)}set length(t){throw new Error("set length() not implemented")}get lensq(){return this.lengthSq}set lensq(t){throw new Error("set lensq() not implemented")}get len(){return this.length}set len(t){throw new Error("set len() not implemented")}get x(){return this[l][P]}set x(t){throw new Error("set x() not implemented")}get y(){return this[l][k]}set y(t){throw new Error("set y() not implemented")}get z(){return this[l][D]}set z(t){throw new Error("set z() not implemented")}get xy(){return new X(this[l][P],this[l][k])}set xy(t){throw new Error("set xz() not implemented")}get xz(){return new X(this[l][P],this[l][D])}set xz(t){throw new Error("set xz() not implemented")}get yz(){return new X(this[l][k],this[l][D])}set yz(t){throw new Error("set yz() not implemented")}[Symbol.iterator](){return this[l].values()}}F(m);G(m,3);w(m,"dot");w(m,"cross");w(m,"crossNormalize");w(m,"toAngles");w(m,"angleTo");w(m,"rotate");w(m,"distance");w(m,"toArray");et(m,"length");et(m,"lengthSq");class xt extends m{set x(t){this[l][P]=t}set y(t){this[l][k]=t}set z(t){this[l][D]=t}get x(){return this[l][P]}get y(){return this[l][k]}get z(){return this[l][D]}calc(t){return j(t,this)}clone(){return new xt(this.x,this.y,this.z)}}class Ut extends m{toVector(){return new xt(this.x,this.y,this.z)}clone(){return this}}const Wt=nt((e,t,n)=>new Ut(e,t,n)),A=(e,t,n)=>Wt(e,t,n);A(0,0,0);const _t=A(0,0,-1);A(0,0,1);const St=A(-1,0,0);A(1,0,0);const $t=A(0,1,0);A(0,-1,0);A(1,1,1);const V=Symbol("angle rad"),Jt=Math.PI/180;class T{constructor(t){t instanceof T?this[V]=t[V]:this[V]=H(t*Jt)}valueOf(){return this[V]}toJSON(){return{angle:this[V]}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,n={}){return L(t,this.toJSON(),n)}}class Pt extends T{set(t){t instanceof T?this[V]=t[V]:this[V]=H((t||0)*Jt)}}class Zt extends T{toDegree(){return new Pt(this[V])}}new Zt(0);function Kt(e){return new Pt(e)}function Bt(e){return M(e)||e instanceof T}const N=0,C=1,_=2,$=3,J=Symbol("axes"),vt=Symbol("forward cache"),te=Symbol("left cache"),ee=Symbol("up cache"),ne=Symbol("inverse cache");function re([e,t,n,r]){return Math.sqrt(e*e+t*t+n*n+r*r)}function oe(e){const t=re(e);e[N]/=t,e[C]/=t,e[_]/=t,e[$]/=t}function se(e,t){const n=e.normalize(),r=t.crossNormalize(n),o=n.crossNormalize(r),s=r.x,i=r.y,u=r.z,h=o.x,c=o.y,a=o.z,f=n.x,x=n.y,S=n.z,Y=s+c+S,y=new Array(4);if(Y>0){let d=Math.sqrt(Y+1);return y[$]=d*.5,d=.5/d,y[N]=(a-x)*d,y[C]=(f-u)*d,y[_]=(i-h)*d,y}if(s>=c&&s>=S){const d=Math.sqrt(1+s-c-S),b=.5/d;return y[N]=.5*d,y[C]=(i+h)*b,y[_]=(u+f)*b,y[$]=(a-x)*b,y}if(c>S){const d=Math.sqrt(1+c-s-S),b=.5/d;return y[N]=(h+i)*b,y[C]=.5*d,y[_]=(x+a)*b,y[$]=(f-u)*b,y}const Vt=Math.sqrt(1+S-s-c),st=.5/Vt;return y[N]=(f+u)*st,y[C]=(x+a)*st,y[_]=.5*Vt,y[$]=(i-h)*st,y}function ie(e,t){const n=new Array(4),r=t*.5,o=Math.sin(r),s=Math.cos(r);return n[N]=o*e.x,n[C]=o*e.y,n[_]=o*e.z,n[$]=s,n}function wt(e,t,n,r){if(M(e))return[e,t,n,r];if(v(e))return[...e];if(Bt(t))return ie(e,t);if(e&&t)return se(e,t)}function ce(e,t,n,r){return e&&M(e.w)?wt(e.x,e.y,e.z,e.w):wt(e,t,n,r)||[0,0,0,1]}class Et{constructor(t,n,r,o){this[J]=ce(t,n,r,o),oe(this[J])}set(t,n,r,o){throw new Error("set x() not implemented")}multiply(t,n,r,o){if(M(t.w))return this.multiplyQuaternion(t);const s=wt(t,n,r,o);return s?this.multiplyQuaternion(new this.constructor(s)):this.multiplyVector(t)}multiplyVector(t){return bt(this,t)}multiplyQuaternion(t){const n=this.x,r=this.y,o=this.z,s=this.w,i=t.x,u=t.y,h=t.z,c=t.w,a=s*i+n*c+r*h-o*u,f=s*u+r*c+o*i-n*h,x=s*h+o*c+n*u-r*i,S=s*c-n*i-r*u-o*h;return new this.constructor(a,f,x,S)}mul(t,n,r,o){return this.multiply(t,n,r,o)}get inverse(){const{x:t,y:n,z:r,w:o}=this;return this.constructor(t*-1,n*-1,r*-1,o)}get inv(){return this.inverse}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z&&this.w===t.w}get left(){return this.multiplyVector(St)}get dir(){return this.multiplyVector(_t)}get up(){return this.multiplyVector($t)}get 0(){return this.left}get 1(){return this.dir}get 2(){return this.up}get x(){return this[J][N]}set x(t){throw new Error("set x() not implemented")}get y(){return this[J][C]}set y(t){throw new Error("set y() not implemented")}get z(){return this[J][_]}set z(t){throw new Error("set z() not implemented")}get w(){return this[J][$]}set w(t){throw new Error("set w() not implemented")}toJSON(){const{x:t,y:n,z:r,w:o}=this;return{x:t,y:n,z:r,w:o,a1:1-n*n*2-r*r*2,a2:t*n*2-r*o*2,a3:t*r*2+n*o*2,b1:t*n*2+r*o*2,b2:1-t*t*2-r*r*2,b3:n*r*2-t*o*2,c1:t*r*2-n*o*2,c2:n*r*2+t*o*2,c3:1-t*t*2-n*n*2}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,n={}){return L(t,this.toJSON(),n)}}F(Et);Ct(Et);function W(e,t,n){let r=e[t];return r||(r=n(),e[t]=r),r}class kt extends Et{get left(){return W(this,te,()=>this.multiplyVector(St))}get dir(){return W(this,vt,()=>this.multiplyVector(_t))}get up(){return W(this,ee,()=>this.multiplyVector($t))}get inverse(){return W(this,ne,()=>{const{x:t,y:n,z:r,w:o}=this;return this.constructor(t*-1,n*-1,r*-1,o)})}}const ue=nt((e,t,n,r)=>new kt(e,t,n,r)),he=(e,t,n,r)=>ue(e,t,n,r);new kt(St,Kt(90));he(0,0,0,1);const le=0,ye=1,ae=2,fe=3,E=Symbol("axes");class Ot{constructor(t,n,r,o){typeof t=="function"?j(t,(s,i,u,h)=>{this[E]=[s,i,u,h]}):v(t)?this[E]=[...t]:t&&M(t.x)?this[E]=[t.x||0,t.y||0,t.z||0,t.w||0]:this[E]=[t||0,n||0,r||0,o||0]}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}valueOf(){throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc")}toArray(){return[this.x,this.y,this.z,this.w]}calc(t){throw new Error("calc() not implemented")}clone(){throw new Error("clone() not implemented")}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z&&this.w===t.w}toJSON(){return{x:this.x,y:this.y,z:this.z,w:this.w}}toString(){return JSON.stringify(this.toJSON())}toCSSVars(t,n={}){return L(t,this.toJSON(),n)}get x(){return this[E][le]}set x(t){throw new Error("set x() not implemented")}get y(){return this[E][ye]}set y(t){throw new Error("set y() not implemented")}get z(){return this[E][ae]}set z(t){throw new Error("set z() not implemented")}get w(){return this[E][fe]}set w(t){throw new Error("set w() not implemented")}[Symbol.iterator](){return this[E].values()}}F(Ot);G(Ot,4);w(Ot,"toArray");const I=Symbol("data");class ot{constructor(...t){this[I]=t}get 0(){return this[I][0]}set 0(t){throw new Error("set [0] not implemented")}get 1(){return this[I][1]}set 1(t){throw new Error("set [1] not implemented")}get 2(){return this[I][2]}set 2(t){throw new Error("set [2] not implemented")}multiplyMat(t){return Rt(this,t)}multiplyVec(t){return Tt(this,t)}multiply(t){if(t instanceof ot)return this.multiplyMat(t);const{x:n,y:r,z:o}=t;if(n===void 0||r===void 0||o===void 0)throw new Error(`multiply only works with mat3 and vec3, not supported ${t}`);return this.multiplyVec(t)}[Symbol.iterator](){return this[I].values()}}F(ot);Ct(ot);export{X as I,zt as i,j as o,we as p,A as v};
