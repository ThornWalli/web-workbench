var e,t=Object.defineProperty,__typeError=e=>{throw TypeError(e)},__publicField=(e,a,r)=>((e,a,r)=>a in e?t(e,a,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[a]=r)(e,"symbol"!=typeof a?a+"":a,r),__privateGet=(e,t,a)=>(((e,t,a)=>{t.has(e)||__typeError("Cannot "+a)})(e,t,"read from private field"),a?a.call(e):t.get(e));import{S as a,I as r}from"./D1WZfvAb.js";import{I as s}from"./BHmTNEz3.js";import{S as i}from"./D3MPJlJW.js";import{O as n}from"./BfpYGSxR.js";class Storage{constructor(e){__publicField(this,"id"),__publicField(this,"_locked",!1),__publicField(this,"storage"),__publicField(this,"name"),__publicField(this,"_data",[]),this.id=e.id,this._locked=e.locked||this._locked,this.storage=e.storage,this.name=e.name}get locked(){return this._locked}get data(){return this._data}set data(e){this._data=e}async mount(...e){return this}async unmount(...e){return this}getItem(e){throw new Error("not implemented")}setItem(e,t){throw new Error("not implemented")}async load(){if(!this.storage)throw new Error("no storage");return this._data}async save(e){if(!this.storage)throw new Error("no storage");return this._data=e||this._data,this._data}}class StorageAdapter{isLogged(){throw new Error("Method not implemented.")}getItem(e){throw new Error("Method not implemented.")}setItem(e,t){throw new Error("Method not implemented.")}removeItem(e){throw new Error("Method not implemented.")}clear(){throw new Error("Method not implemented.")}}class FallbackAdapter extends StorageAdapter{constructor(){var t,a,r;super(...arguments),t=this,a=e,r=new Map,a.has(t)?__typeError("Cannot add the same private member more than once"):a instanceof WeakSet?a.add(t):a.set(t,r)}isLogged(){return!0}getItem(t){return __privateGet(this,e).get(t)||null}setItem(t,a){__privateGet(this,e).set(t,a)}removeItem(t){__privateGet(this,e).delete(t)}clear(){__privateGet(this,e).clear()}}e=new WeakMap;class TempStorage extends Storage{constructor(e){super({...e,storage:new FallbackAdapter})}}class LocalStorageAdapter extends StorageAdapter{isLogged(){return!0}getItem(e){return localStorage.getItem(e)}setItem(e,t){localStorage.setItem(e,JSON.stringify(t))}removeItem(e){localStorage.removeItem(e)}clear(){localStorage.clear()}}class WebStorage extends Storage{async mount(){let e;if(this.storage instanceof Storage){const a=this.storage;try{if(e=a.getItem(this.name),!e)throw new Error("json invalid");if(e=JSON.parse(e),!(e&&e instanceof Object))throw new Error("json invalid")}catch(t){console.error(t),e={}}this.storage.setItem(this.name,e)}return this}async load(){return this.storage&&this.storage instanceof StorageAdapter&&(this.data=JSON.parse(this.storage.getItem(this.name)||"[]")),this.data}async save(e){return this.storage&&this.storage instanceof StorageAdapter&&(this.data=e||this.data,this.storage.setItem(this.name,this.data)),this.data}}class LocalStorage extends WebStorage{constructor(e){super({...e,storage:new LocalStorageAdapter})}}class SessionStorageAdapter extends StorageAdapter{isLogged(){return!0}getItem(e){return sessionStorage.getItem(e)}setItem(e,t){sessionStorage.setItem(e,JSON.stringify(t))}removeItem(e){sessionStorage.removeItem(e)}clear(){sessionStorage.clear()}}class SessionStorage extends WebStorage{constructor(e){super({...e,storage:new SessionStorageAdapter})}}class CloudStorage extends Storage{constructor(e){super({...e})}isLogged(){throw new Error("Not implemented")}}var o=(e=>(e[e.NONE=0]="NONE",e[e.AUTO=1]="AUTO",e[e.TEMP=3]="TEMP",e[e.LOCAL=4]="LOCAL",e[e.SESSION=5]="SESSION",e[e.CLOUD=6]="CLOUD",e))(o||{});function getStorageByType(e){switch(e){case 3:default:return TempStorage;case 4:return LocalStorage;case 5:return SessionStorage;case 6:return CloudStorage}}function isStringValue(e){return"string"==typeof e&&hasStringWrap(e.trim())}const m=['"',"'"];function wrapString(e,t='"'){return hasStringWrap(e)?e:`${t}${e=e.replace(/"/g,'\\"')}${t}`}function isEmptyStringWrap(e){return 2===e.length&&e[0]===e[e.length-1]&&hasStringWrap(e)}function hasStringWrap(e){return e[0]===e[e.length-1]&&m.includes(e[0])}function unwrapString(e){if("string"==typeof e){const t=e.trim();if(hasStringWrap(t))return t.slice(1,e.length-1).replace(/\\"/g,'"')}return e}function isBoolean(e){return"boolean"==typeof e||"true"===e||"false"===e}function isNumeric(e){return!isNaN(e)&&!isNaN(parseFloat(e))}function atob(e){return decodeURIComponent(globalThis.atob(e))}function btoa(e){return globalThis.btoa(encodeURIComponent(e))}const c=new class ErrorMessage{constructor(){__publicField(this,"items",new Map)}add(e,t){Array.isArray(e)?e.forEach(([e,t])=>{this.add(e,t)}):t&&(Array.isArray(t)||(t=[t]),this.items.set(e,t))}get(...e){var t;const a=e.shift()||"";return null==(t=this.items.get(a))?void 0:t.map(t=>e.reduce((e,t)=>e.replace(/%\d+/,t),t))}};c.add("bad_args","Bad args"),c.add("cant_find","Can't find %1");const h="ROOT";function getItemId(e){return"object"==typeof e&&"id"in e?e.id:e.replace(/.*[\\/:]{1,1}([^:\\/]+)$/,"$1")}function pathJoin(...e){return e.reduce((e,t)=>(e.push(...t.replace(/[\\/]+/,"/").replace(/^\//,"").replace(/\/$/,"").split("/")),e),[]).join("/").replace(/:\//,":").replace(/\/$/,"")}function getDirname(e){const t=function getRootId(e){return e.replace(/([\w]*[\\:]).*/,"$1")}(e),a=getFilename(e);let r=function getPath(e){return e.replace(/.*:([\w/.]+)$/,"$1")}(e);return r=r.slice(0,r.length-a.length),t+r}function getFilename(e){return/^.*[\\/:]([\w]+\.[\w]+)$/.test(e)?e.replace(/^.*[\\/:]([\w]+\.[\w]+)$/,"$1"):/^([\w]+\.[\w]+)$/.test(e)?e.replace(/^([\w]+\.[\w]+)$/,"$1"):""}function getItemPath(e){return e.replace(/(.*[\\/:]{1,1})[^:\\/]+$/,"$1")}function isValidPath(e){return e.length&&/^[\w .\\/:-]+$/.test(e)}function removeExt(e){return e.replace(/^(.*)\.[^.]+$/,"$1")}function getExt(e){const t=e.match(/^.*\.([^.]*)$/);return t?t[1]:""}function formatId(e){return e.replace(/[^.a-zA-Z0-9_-]/g,"_")}function addExt(e,t){return t?`${removeExt(e)}.${t}`:e}function getNextItemId(e,t,a){let r=e;return t.hasItem(addExt(r,a))?(r=`copy_${e}`,t.hasItem(addExt(r,a))?getNextItemId(r,t,a):r):r}function checkItemStoragePermission(e){var t;const a=getStorageItem(e);if(a){if(null==a?void 0:a.locked)throw new Error(null==(t=c.get("FileSystem_permissionsNeeded"))?void 0:t.join(" "));return e}return e}async function saveStorageItem(e,t){return(t=t||getStorageItem(e))&&(await e.save(),await t.save()),e}function getStorageItem(e){return e.storage?e:e.parent?getStorageItem(e.parent):void 0}class Event{constructor({name:e,value:t,scope:a}){__publicField(this,"name"),__publicField(this,"value"),__publicField(this,"scope"),this.name=e,this.value=t,this.scope=a}}const d={basic:a.BASIC,bas:a.BASIC,markdown:a.DISK_MARKDOWN,md:a.DISK_MARKDOWN,image:a.IMAGE,img:a.IMAGE};function getSymbolByExt(e,t=a.NOTE_BLANK){return d[getExt(e).toLowerCase()]||t}class ItemEvent extends Event{}class Item{constructor(e,{type:t,symbol:s=a.NOTE_BLANK}={type:"Unknown",symbol:a.NOTE_BLANK}){__publicField(this,"type"),__publicField(this,"events"),__publicField(this,"_locked",!1),__publicField(this,"parent"),__publicField(this,"createdDate"),__publicField(this,"editedDate"),__publicField(this,"id"),__publicField(this,"_name",""),__publicField(this,"meta"),__publicField(this,"_data"),__publicField(this,"_action");const{locked:o=!1,id:m,name:c,meta:h,data:d,action:l,createdDate:g=Date.now(),editedDate:u}=e;this.events=n(new i),this.createdDate=g||Date.now(),this.editedDate=u||g,this._locked=o||!1,this.id=m,this._name=c||"",this.type=t||"Unknown",this.meta=new Map([[r.SYMBOL,getSymbolByExt(m||"",s||a.NOTE_BLANK)],[r.VISIBLE,!0],...h||[]]);let I=d;if("string"==typeof d)try{I=JSON.parse(d)}catch(p){throw console.log(I),p}this._action=l,this._data=function prepareDataForItem(e){"object"==typeof e&&(e=JSON.stringify(e));return e}(I||{})}async remove(e={}){var t,a;const{silent:r}=Object.assign({silent:!1},e);let s;const i=this.isLocked();if(i){if(!r)throw new Error(null==(t=c.get("FileSystemItem_itemLocked",await this.getPath()))?void 0:t.join(" "))}else s={type:this.type,id:this.id,name:this.name,path:await this.getPath(),size:this.size,storage:getStorageItem(this)};return!r&&i||(this.events.next(new Event({name:"remove",value:{item:this}})),this.events.unsubscribe(),null==(a=this.parent)||a.removeItem(this)),s?[s]:[]}isLocked(e=!1){return!e&&(!(!this.parent||!this.parent.locked||this.parent.id===h)||this._locked)}async copy(){const e=new(0,this.constructor)(await this.export({encodeData:!1}));return Promise.resolve(e)}rename(e,t={}){const{name:a=!1,ignore:r=!1}=Object.assign({name:!1,ignore:!1},t);if(!this.isLocked(r)){if(a)return this.name=e,this;{const t=this.id;this.id=formatId(e||""),this.parent&&t!==this.id&&this.parent.changeItemId(this,t,this.id)}this.events.next(new ItemEvent({name:"rename",value:{item:this}}))}return this}save(){this.events.next(new Event({name:"save",value:{item:this}}))}getUsedMemory(){return this.size/this.maxSize}async export(e={}){const{encodeData:t}=Object.assign({encodeData:!0},e),a=new Map(this.meta);let r;return Array.from(a.keys()).forEach(e=>{a.get(e)instanceof s&&a.set(e,a.get(e).toJSON())}),r=t&&"string"==typeof this._data?await btoa(this._data):this._data,{type:this.type,id:this.id,name:this._name,createdDate:this.createdDate,editedDate:this.editedDate,data:r,meta:Array.from(a)}}get data(){let e=this._data;if("string"==typeof this._data)try{e=JSON.parse(this._data)}catch(t){console.error(t),e={type:"markdown",content:"Cannot parse data"}}return e}set data(e){"object"==typeof e&&(e=JSON.stringify(e)),this._data=e}get action(){return this._action}setId(e){this.id=e}setParent(e){this.parent=e}get locked(){var e;return(null==(e=this.parent)?void 0:e.locked)||this._locked}get name(){return this._name||this.id}set name(e){this._name=e||""}get extension(){return getExt(this.id)}get size(){const e=Object.values(this.data||{});return new Blob(e).size}get maxSize(){return new Blob(Object.values(this.data||{})).size}getRealMaxSize(){return new Blob(Object.values(this.data||{})).size}getBase(){return Item.getBaseRecursive({item:this},!1)}getPath(){return Item.getBaseRecursive({item:this})}static getBaseRecursive({item:e,path:t=[]},a=!0){if(a&&t.push(e.id),e.parent)return Item.getBaseRecursive({item:e.parent,path:t});if((t=t.reverse())[0]===h&&t.shift(),t.length>0){let e=t[0];return/\./.test(e)||(e+=":"),`${e}${t.slice(1,t.length).join("/")}`}return h}}c.add([["FileSystemItem_itemLocked",["Item Locked","Item is locked, can't be edit… %1"]]]);class ItemContainer extends Item{constructor(e,t){super(e={...e},t),__publicField(this,"items",new Map),__publicField(this,"_maxSize",function kilobyteToByte(e){return 1e3*e}(1)),this.addItems(e.items||this.items),this._maxSize=e.maxSize||this._maxSize}async export(e={}){const t={...await super.export(e),items:[]};return Reflect.deleteProperty(t,"data"),t.items=await Promise.all(Array.from(this.items.values()).map(e=>e.export())),t}async addItems(e,t=!1){let a=[];e instanceof Map?a=Array.from(e.values()):Array.isArray(e)&&(a=e),a=a.map(e=>("string"==typeof e.data&&(e.data=atob(e.data)),e));const r=this.parseItems(a);return Promise.all(r.map(e=>this.addItem(e,t)))}static normalizeItemData(e){const t={...e},a=[];return!("items"in e)||e.items instanceof Map||(t.items=new Map(e.items.map(e=>[e.id,e]))),"info"in e&&e.info,"extension"in t&&(t.id+="."+t.extension,delete t.extension,a.push("extension")),"createTime"in t&&(t.createdDate=t.createTime,delete t.createTime,a.push("createTime")),"editTime"in t&&(t.editedDate=t.editTime,delete t.editTime,a.push("editTime")),"icon"in t&&(delete t.icon,a.push("icon")),a.length&&console.warn("@deprecated TODO: muss weg, hier werden die alten Items angepasst.",t,a),t}parseItems(e){return e.map(e=>{const t=ItemContainer.normalizeItemData(e);let a;return a=t.type?getClass(t.type):"items"in t?getClass("Directory"):getClass(),new a(t)})}async addItem(e,t=!1){const a=e.parent;if(!t&&this.hasItem(e.id))throw new Error(`File ${e.id} exists`);if(a&&await a.removeItem(e),t){const t=getExt(e.id),a=removeExt(e.id);e.setId(addExt(getNextItemId(a,this,t),t))}return this.items.set(e.id,e),e.setParent(this),e.events.next(new Event({name:"move",value:{item:e,lastParent:a}})),this.events.next(new Event({name:"addItem",value:{item:e}})),e}removeItem(e){return e.setParent(void 0),this.items.delete(e.id),this.events.next(new Event({name:"removeItem",value:{item:e}})),Promise.resolve()}async remove(e={}){var t;const{recursive:a}={recursive:!1,...e},r=[];if(a){const t=await this.getItems();for(const a of t.values())r.push(...await a.remove(e));return r.push(...await super.remove(e)),r}if((await this.getItems()).size>0)throw new Error(null==(t=c.get("FileSystemItem_itemContainerNotEmpty",await this.getPath()))?void 0:t.join(" "));return await super.remove(e)}changeItemId(e,t,a){this.items.delete(t),this.items.set(a,e),this.parent&&console.log("changeItemId by parent",t,a,this.parent.items)}getItems(){return Promise.resolve(this.items)}getItem(e){return this.items.get(e)}hasItem(e){return this.items.has(e)}get size(){return Array.from(this.items.values()).reduce(function(e,t){return t instanceof ItemContainer||(e+=t.size),e},0)}get maxSize(){return function getMaxSizeFromParent(e){return e.parent&&e.getRealMaxSize()?getMaxSizeFromParent(e.parent):e.getRealMaxSize()}(this)}}c.add([["FileSystemItem_itemContainerNotEmpty",["ItemWrapp Not Empty","ItemContainer not empty… %1"]]]);class ItemStorage extends ItemContainer{constructor(e,t){super(e={...e,locked:!0},t),__publicField(this,"storage"),this.storage=e.storage}get locked(){return this.storage.locked}mount(...e){return this.storage.mount(...e)}unmount(...e){return this.storage.unmount(...e)}async save(){return this.storage.save(await this.export())}}__publicField(ItemStorage,"TYPE","Storage");const l=class _CloudDisk extends ItemStorage{constructor(e){super(e,{type:_CloudDisk.TYPE,symbol:a.CLOUD_DISK})}isLogged(e=!1){var t;return e||(null==(t=this.storage.storage)?void 0:t.isLogged())||!1}isLocked(e){return this.isLogged(e)&&super.isLocked(e)}};__publicField(l,"TYPE","CloudDisk");let g=l;class Directory extends ItemContainer{constructor(e){super(e,{type:"Directory",symbol:a.DIRECTORY}),[r.WINDOW_SCALE,r.WINDOW_SCROLL_X,r.WINDOW_SCROLL_Y].forEach(e=>{this.meta.has(e)||this.meta.set(e,!0)})}}__publicField(Directory,"TYPE","Directory");class File extends Item{constructor(e){super(e,{type:"File"})}}__publicField(File,"TYPE","File");class FloppyDisk extends ItemContainer{constructor(e){super(e,{type:"FloppyDisk"})}}__publicField(FloppyDisk,"TYPE","FloppyDisk");class HardDisk extends ItemStorage{constructor(e){super(e,{type:"HardDisk",symbol:a.HARD_DISK})}}__publicField(HardDisk,"TYPE","HardDisk");class Link extends Item{constructor(e){super(e={refPath:void 0,...e}),__publicField(this,"refPath"),this.refPath=e.refPath}}__publicField(Link,"TYPE","Link");class RamDisk extends ItemStorage{constructor(e){super(e,{type:"RamDisk",symbol:a.RAM_DISK})}}__publicField(RamDisk,"TYPE","RamDisk");class Root extends ItemContainer{constructor(e){super(e={...e,locked:!0,id:"ROOT",name:"ROOT"},{type:"Root"})}}__publicField(Root,"TYPE","Root");class TmpDisk extends ItemStorage{constructor(e){super(e,{type:"TmpDisk",symbol:a.TMP_DISK}),this.meta.set(r.VISIBLE,!1),this.meta.set(r.IGNORE_SYMBOL_REARRANGE,!0)}}__publicField(TmpDisk,"TYPE","TmpDisk");class Trashcan extends ItemContainer{constructor(e){super(e,{type:"Trashcan",symbol:a.TRASHCAN})}}__publicField(Trashcan,"TYPE","Trashcan");const u=class _FileSystem{constructor(e){__publicField(this,"name"),__publicField(this,"root"),__publicField(this,"currentItem"),__publicField(this,"storages",new Map),__publicField(this,"events",n(new i)),this.name=e,this.root=new Root,this.setup()}setup(){this.currentItem=this.root;const e=[this.addStorage(_FileSystem.RAM_DISK_TITLE,o.SESSION,{id:_FileSystem.RAM_DISK_NAME}),this.addStorage(_FileSystem.HARD_DISK_NAME,o.LOCAL,{trashcan:!0}),this.addStorage(_FileSystem.TMP_DISK_TITLE,o.TEMP,{id:_FileSystem.TMP_DISK_NAME,trashcan:!1})];return Promise.all(e).catch(e=>{throw e})}createTmpFile(e,t,a,r){return this.createRootFile(`TMP:${e}`,t,a,r)}createRootDir(e,t,a){const r=`${e}`;return this.makedir(r,t,{override:!0,...a})}createRootFile(e,t,a,r){let s=t,i=a;"object"==typeof t&&(i=t,s=void 0);const n=`${e||"Unknown"}`;return this.makeFile(n,s,i,{...r||{},override:!0})}async get(e,t=!1){if(e instanceof Item)return e;if(!isValidPath(e))throw c.get("FileSystem_pathInvalid",getItemId(e),getItemPath(e));try{return await this.parsePath(e)}catch(a){if(t)return new Item({id:getItemId(e),name:getItemId(e)});throw a}}async parsePath(e){var t,a;let r=e,s=this.currentItem;const i=e.match(/^([^:\\/]+):(.*)$/);if(i?(s=null==(t=this.root)?void 0:t.getItem(i[1]),r=i[2]):"/"===r[0]&&this.currentItem?(r=r.slice(1),s=getStorageItem(this.currentItem)):"ROOT"===r?(s=this.root,r=""):!r||r.includes("/")||/^\.+$/.test(r.trim())||(s=this.root.getItem(r),r=""),r&&r.length>0&&(s=changeItemRecursive(r.split("/"),s)),s)return s;throw c.get("FileSystem_pathInvalid",e,await(null==(a=this.currentItem)?void 0:a.getBase())||"")}async addFloppyDisk(e){let t;if("function"==typeof e?(t=await e(),t instanceof Promise&&(t=await t)):t=e,Array.isArray(t))throw new Error('data is an Array, use "defineFloppyDisk" for define a Disk');return this.addStorage(t)}async removeFloppyDisk(e){await e.remove({silent:!0})}async addStorage(e,t,s={}){let i;s=Object.assign({id:null},s),"function"==typeof t&&(i=t,t=o.CLOUD);const n=this.getFreeSlot(_FileSystem.PREFIX.FLOPPY_DISK),m={id:n,itemClass:FloppyDisk,items:new Map};let c={};if("object"==typeof e){const t=e;m.name=t.name||t.id,t.items&&(m.items=t.items),m.meta=Array.from(new Map([[r.SYMBOL,a.DISK_1],...t.meta||[]]))}else{switch(t){case o.SESSION:m.id=_FileSystem.PREFIX.RAM,m.itemClass=RamDisk;break;case o.TEMP:m.id=_FileSystem.PREFIX.TMP,m.itemClass=TmpDisk;break;case o.LOCAL:m.id=this.getFreeSlot(_FileSystem.PREFIX.HARD_DISK),m.itemClass=HardDisk;break;case o.CLOUD:m.id=this.getFreeSlot(_FileSystem.PREFIX.CLOUD_DISK),m.itemClass=g}let a;m.id=s.id||m.id,a=i&&"function"==typeof i?await this.registerStorageByStorage(m.id,i).mount(s):await this.registerStorageByType(m.id,t).mount(s);const r=await a.load();c=ItemContainer.normalizeItemData(r),m.storage=a,o.NONE!==t&&(m.name=c.name||c.id||e)}return(m.meta=m.meta||[]).push(...c.meta||[]),this.addDisk({...m,...c,storage:m.storage||new TempStorage({id:n,name:_FileSystem.TMP_DISK_TITLE})},s)}removeStorage(e){return e.unmount().then(()=>(this.events.next(new Event({name:"removeStorage",value:{itemStorage:e}})),e))}registerStorageByType(e,t){const a=getStorageByType(t),r=`${this.name}_${e}`,s=new a({id:e,name:r});return this.storages.set(r,s),s}registerStorageByStorage(e,t){const a=`${this.name}_${e}`,r=new t({id:e,name:a});return this.storages.set(a,r),r}connect(e,t){return this.addStorage("CLOUD",e,t).then(e=>e).catch(e=>{throw e})}async disconnect(e){return(e=await this.removeStorage(e)).remove({silent:!0,recursive:!0}),e}addDisk({id:e,name:t,meta:a,items:r,itemClass:s,storage:i},n){var o;n={trashcan:!1,...n},r instanceof Map&&n.trashcan&&(!r||r&&!r.has(Trashcan.TYPE))&&(r=r||new Map).set(Trashcan.TYPE,{type:Trashcan.TYPE,id:Trashcan.TYPE,name:Trashcan.TYPE});const m=s;if(!m)throw new Error("ItemClass is empty!");const c=new m({id:e,name:t||e,meta:a,items:r,storage:i});return null==(o=this.root)||o.addItem(c),this.events.next(new Event({name:"addDisk",value:{id:e,item:c}})),c}getFreeSlot(e){var t;let a=0;for(;null==(t=this.root)?void 0:t.hasItem(`${e}${a}`);)a++;return`${e}${a}`}async exist(e){try{return!!(await this.get(e))}catch(t){return console.error(t),!1}}async changeDirectory(e){const t=await this.get(e);return this.currentItem=t,this.events.next(new Event({name:"changeDirectory",value:t})),t}async makedir(e,t,a){const{override:r,meta:s}={override:!1,meta:[],...a};let i;i=e&&function isPath(e){return isValidPath(e)&&!(!e.includes("/")&&!e.match(/^([^:]+):.*/))}(e)&&e!==t?await this.get(getItemPath(e)):this.currentItem;const n=new Directory({id:getItemId(e),name:t||"",createdDate:Date.now(),meta:s});if(await checkItemStoragePermission(i),!r&&i.getItem(n.id))throw c.get("FileSystem_fileExist",n.id);return i.addItem(n,r),this.events.next(new Event({name:"writeItem",value:n})),await saveStorageItem(i),n}async makeFile(e,t,a,r){var s,i,n;const{override:o,meta:m}={...r,meta:r.meta||[]},h=getItemId(e),d=new File({id:h,name:t||h,data:a,meta:m,createdDate:Date.now()});if(!isValidPath(e))throw c.get("FileSystem_invalidPath",e);let l=getDirname(e);const g=getFilename(e);let u;if(l===g&&(l="."),u=function isAbsolutePath(e){return/^[a-zA-Z0-9_-]+:/.test(e)}(l)?await this.get(l):"ROOT"!==(null==(s=this.currentItem)?void 0:s.id)?await this.get(pathJoin(await(null==(i=this.currentItem)?void 0:i.getPath())||"",l)):await this.get(l),u.hasItem(g)){if(!o)throw c.get("FileSystem_fileExist",d.id);await(null==(n=u.getItem(g))?void 0:n.remove()),u.addItem(d)}else u.addItem(d),this.events.next(new Event({name:"writeItem",value:d}));return await saveStorageItem(u),d}async editFile(e,t){const a=await this.get(e);return await checkItemStoragePermission(a),await async function checkItemLocked(e){var t;if(e.locked)throw new Error(null==(t=c.get("FileSystemItem_itemLocked",await e.getPath()))?void 0:t.join(" "));return e}(a),a.data=t,saveStorageItem(a)}async editFileMeta(e,t,a){const r=await this.get(e);return Array.isArray(t)?t.map(e=>({name:e[0],value:e[1]})):r.meta.set(t,a),saveStorageItem(r)}async cleanFileMeta(e,{force:t}={}){const a=await this.get(e);return await checkItemStoragePermission(a),a.meta=t?new Map:new Map(Array.from(a.meta.entries()).filter(([,e])=>void 0!==e)),saveStorageItem(a)}async getItemMetaList(e){const t=await this.get(e);return Array.from(t.meta).map(e=>({name:e[0],value:e[1]}))}async saveItem(e){return saveStorageItem(await this.get(e))}async makelink(e,t=null){const a=await this.get(e);await checkItemStoragePermission(a);const s=this.currentItem,i=new Link({id:removeExt(a.id)+".ref",name:`${t||a.name}`,createdDate:Date.now(),meta:[[r.REFERENCE,await a.getPath()]]});return await s.addItem(i),await saveStorageItem(a),i}async editlink(e,t){const a=await this.get(e);await checkItemStoragePermission(a);const r=await this.get(t);return a.refPath=await r.getPath(),saveStorageItem(a)}async rename(e,t,{name:a,removeName:r}={name:!1,removeName:!1}){let s;if(e instanceof Item)s=e;else{if(!isValidPath(e)&&"string"!=typeof e)throw c.get("FileSystem_pathInvalid",getItemPath(e),e);s=await this.get(e)}return await checkItemStoragePermission(s),r&&(a=!0,t=void 0),await s.rename(t,{ignore:!0,name:a}),saveStorageItem(s)}async copy(e,t,a={ignore:!1}){const{ignore:r}={ignore:!1,...a};let s,i,n;if(e instanceof Item?(i=e,s=e.id):(i=await this.get(e),s=getItemId(e)),t instanceof Item)t instanceof ItemContainer||(t=t.parent),n=t;else{if(!t)throw new Error('"to" is empty!');{s=getItemId(t);const e=await this.get(t,!0);if(n=e.parent?e.parent:await this.get(getItemPath(t)),!(n instanceof ItemContainer))throw new Error("no ItemContainer")}}await checkItemStoragePermission(i);const o=await i.copy();if(!(n instanceof ItemContainer)||!r&&n.getItem(s))throw c.get("FileSystem_fileExist",s);return o.rename(s),n.addItem(o,r),this.events.next(new Event({name:"copyItem",value:o})),saveStorageItem(o)}async move(e,t,{override:a}={}){let r,s,i,n;if(e instanceof Item)s=e,r=e.id;else{if(s=await this.get(e),s instanceof ItemStorage)throw c.get("FileSystem_cantMoveStorage",s.id);r=getItemId(e)}if(t instanceof Item)i=t instanceof ItemContainer?t:t.parent;else{if(r=getItemId(t),i=await this.get(t),!(i instanceof ItemContainer))return this.get(getItemPath(t));if(r=getItemId(e),!(i instanceof ItemContainer))throw new Error("no ItemContainer")}if(await checkItemStoragePermission(s),!a&&await i.getItem(r))throw c.get("FileSystem_fileExist",s.id,r);return n=getStorageItem(s),await s.rename(r),await i.addItem(s,a),this.events.next(new Event({name:"moveItem",value:s})),await saveStorageItem(s),n?n.save().then(()=>s):s}async remove(e,t,a={ignore:!1}){var r;const{ignore:s}={ignore:!1,...a},i=await this.get(e);await checkItemStoragePermission(i);try{const e=await async function removeItem(e,t){const a=await t.remove({recursive:e});return Array.isArray(a)?a:[a]}(t,i);return e[e.length-1].storage&&await(null==(r=e[e.length-1].storage)?void 0:r.save()),e}catch(n){if(!s)throw n}}};__publicField(u,"PREFIX",{FLOPPY_DISK:"DF",TMP:"TMP",RAM:"RAM",HARD_DISK:"HD",CLOUD_DISK:"CD"}),__publicField(u,"TMP_DISK_NAME","TMP"),__publicField(u,"TMP_DISK_TITLE","TMP DISK"),__publicField(u,"RAM_DISK_NAME","RAM"),__publicField(u,"RAM_DISK_TITLE","RAM DISK"),__publicField(u,"HARD_DISK_NAME","HARD DISK");let I=u;function changeItemRecursive(e,t){const a=e.shift();if(void 0===a)return t;if(".."===a){if(t.parent)return t.parent}else if("."===a||""===a)return changeItemRecursive(e,t);if(t){const r=t.getItem(a);return e.length>0&&r instanceof ItemContainer?changeItemRecursive(e,r):r}}function getClass(e){switch(e){case Directory.TYPE:return Directory;case Trashcan.TYPE:return Trashcan;case ItemStorage.TYPE:return ItemStorage;case TmpDisk.TYPE:return TmpDisk;case RamDisk.TYPE:return RamDisk;case HardDisk.TYPE:return HardDisk;case FloppyDisk.TYPE:return FloppyDisk;case g.TYPE:return g;case Link.TYPE:return Link;case File.TYPE:return File}return File}c.add([["FileSystem_invalidPath",["Invalid File",'Invalid path "%1"']],["FileSystem_invalidFile",["Invalid File",'Invalid file… "%1"']],["FileSystem_fileExist",["File Ready",'File already exists… "%1"']],["FileSystem_pathInvalid",["Path Invalid",'Path invalid… "%1"; base: "%2"']],["FileSystem_itemInvalid",["Item Invalid",'Item id invalid… "%1" from "%2"']],["FileSystem_cantMoveStorage",["Can't Move",'Can\'t move BaseStorage "%1"']],["FileSystem_permissionsNeeded",["Permissions needed","Permissions needed"]]]);export{CloudStorage as C,Directory as D,Event as E,I as F,ItemStorage as I,Root as R,StorageAdapter as S,o as T,getExt as a,isBoolean as b,Trashcan as c,ItemContainer as d,c as e,formatId as f,getStorageByType as g,getItemId as h,isNumeric as i,atob as j,addExt as k,File as l,isEmptyStringWrap as m,isStringValue as n,Item as o,pathJoin as p,getDirname as q,btoa as r,saveStorageItem as s,unwrapString as u,wrapString as w};
