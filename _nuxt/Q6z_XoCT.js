var oe=Object.defineProperty;var Q=r=>{throw TypeError(r)};var ce=(r,e,t)=>e in r?oe(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var o=(r,e,t)=>ce(r,typeof e!="symbol"?e+"":e,t),me=(r,e,t)=>e.has(r)||Q("Cannot "+t);var O=(r,e,t)=>(me(r,e,"read from private field"),t?t.call(r):e.get(r)),ee=(r,e,t)=>e.has(r)?Q("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t);import{S as u,I as E}from"./CFct_F1V.js";import{I as le}from"./CpIyErmU.js";import{S as se}from"./RAasLaaH.js";import{O as re}from"./oWuEt9Fj.js";class b{constructor(e){o(this,"id");o(this,"_locked",!1);o(this,"storage");o(this,"name");o(this,"_data",[]);this.id=e.id,this._locked=e.locked||this._locked,this.storage=e.storage,this.name=e.name}get locked(){return this._locked}get data(){return this._data}set data(e){this._data=e}async mount(...e){return this}async unmount(...e){return this}getItem(e){throw new Error("not implemented")}setItem(e,t){throw new Error("not implemented")}async load(){if(!this.storage)throw new Error("no storage");return this._data}async save(e){if(!this.storage)throw new Error("no storage");return this._data=e||this._data,this._data}}class L{isLogged(){throw new Error("Method not implemented.")}getItem(e){throw new Error("Method not implemented.")}setItem(e,t){throw new Error("Method not implemented.")}removeItem(e){throw new Error("Method not implemented.")}clear(){throw new Error("Method not implemented.")}}var T;class de extends L{constructor(){super(...arguments);ee(this,T,new Map)}isLogged(){return!0}getItem(t){return O(this,T).get(t)||null}setItem(t,s){O(this,T).set(t,s)}removeItem(t){O(this,T).delete(t)}clear(){O(this,T).clear()}}T=new WeakMap;class J extends b{constructor(e){super({...e,storage:new de})}}class he extends L{isLogged(){return!0}getItem(e){return localStorage.getItem(e)}setItem(e,t){localStorage.setItem(e,JSON.stringify(t))}removeItem(e){localStorage.removeItem(e)}clear(){localStorage.clear()}}class ae extends b{async mount(){let e;if(this.storage instanceof b){const t=this.storage;try{if(e=t.getItem(this.name),e){if(e=JSON.parse(e),!e||!(e instanceof Object))throw new Error("json invalid")}else throw new Error("json invalid")}catch(s){console.error(s),e={}}this.storage.setItem(this.name,e)}return this}async load(){return this.storage&&this.storage instanceof L&&(this.data=JSON.parse(this.storage.getItem(this.name)||"[]")),this.data}async save(e){return this.storage&&this.storage instanceof L&&(this.data=e||this.data,this.storage.setItem(this.name,this.data)),this.data}}class ue extends ae{constructor(e){super({...e,storage:new he})}}class fe extends L{isLogged(){return!0}getItem(e){return sessionStorage.getItem(e)}setItem(e,t){sessionStorage.setItem(e,JSON.stringify(t))}removeItem(e){sessionStorage.removeItem(e)}clear(){sessionStorage.clear()}}class ge extends ae{constructor(e){super({...e,storage:new fe})}}class we extends b{constructor(e){super({...e})}isLogged(){throw new Error("Not implemented")}}var S=(r=>(r[r.NONE=0]="NONE",r[r.AUTO=1]="AUTO",r[r.TEMP=3]="TEMP",r[r.LOCAL=4]="LOCAL",r[r.SESSION=5]="SESSION",r[r.CLOUD=6]="CLOUD",r))(S||{});function Ie(r){switch(r){case 3:return J;case 4:return ue;case 5:return ge;case 6:return we;default:return J}}function Ye(r){return typeof r=="string"&&U(r.trim())}const ye=['"',"'"];function je(r,e='"'){return U(r)?r:(r=r.replace(/"/g,'\\"'),`${e}${r}${e}`)}function Ue(r){return r.length===2&&r[0]===r[r.length-1]&&U(r)}function U(r){return r[0]===r[r.length-1]&&ye.includes(r[0])}function We(r){if(typeof r=="string"){const e=r.trim();if(U(e))return e.slice(1,r.length-1).replace(/\\"/g,'"')}return r}function He(r){return typeof r=="boolean"||r==="true"||r==="false"}function Je(r){return!isNaN(r)&&!isNaN(parseFloat(r))}function pe(r){return decodeURIComponent(globalThis.atob(r))}function Se(r){return globalThis.btoa(encodeURIComponent(r))}class ve{constructor(){o(this,"items",new Map)}add(e,t){Array.isArray(e)?e.forEach(([s,a])=>{this.add(s,a)}):t&&(Array.isArray(t)||(t=[t]),this.items.set(e,t))}get(...e){var s;const t=e.shift()||"";return(s=this.items.get(t))==null?void 0:s.map(a=>e.reduce((i,n)=>i.replace(/%\d+/,n),a))}}const d=new ve;d.add("bad_args","Bad args");d.add("cant_find","Can't find %1");const De="/",W="ROOT",Ee="CLOUD";function p(r){return typeof r=="object"&&"id"in r?r.id:r.replace(/.*[\\/:]{1,1}([^:\\/]+)$/,"$1")}function _e(r){return/^[a-zA-Z0-9_-]+:/.test(r)}function Pe(...r){return r.reduce((e,t)=>(e.push(...t.replace(/[\\/]+/,"/").replace(/^\//,"").replace(/\/$/,"").split("/")),e),[]).join("/").replace(/:\//,":").replace(/\/$/,"")}function Te(r){return r.replace(/(.*)[:/]([^\\/:]+)/,"$1")}function Me(r){return r.replace(/^(.*)[\\/:]([^\\/:]+)$/,"$2")}function x(r){return r.replace(/(.*[\\/:]{1,1})[^:\\/]+$/,"$1")}function N(r){return r.length&&/^[\w .\\/:-]+$/.test(r)}function Ae(r){return N(r)&&!!(r.includes("/")||r.match(/^([^:]+):.*/))}function Oe(r){return r*1e3}function V(r){return r.replace(/^(.*)\.[^.]+$/,"$1")}function Z(r){const e=r.match(/^.*\.([^.]*)$/);return e?e[1]:""}function xe(r){return r.replace(/[^.a-zA-Z0-9_-]/g,"_")}function X(r,e){return e?`${V(r)}.${e}`:r}function ie(r,e,t){let s=r;return e.hasItem(X(s,t))?(s=`copy_${r}`,e.hasItem(X(s,t))?ie(s,e,t):s):s}async function ke(r){var e;if(r.locked)throw new Error((e=d.get("FileSystemItem_itemLocked",await r.getPath()))==null?void 0:e.join(" "));return r}function D(r){var t;const e=A(r);if(e){if(e!=null&&e.locked)throw new Error((t=d.get("FileSystem_permissionsNeeded"))==null?void 0:t.join(" "));return r}return r}async function I(r,e){return e=e||A(r),e&&(await r.save(),await e.save()),r}async function Le(r,e){const t=await e.remove({recursive:r});return Array.isArray(t)?t:[t]}function A(r){if(r.storage)return r;if(r.parent)return A(r.parent)}class w{constructor({name:e,value:t,scope:s}){o(this,"name");o(this,"value");o(this,"scope");this.name=e,this.value=t,this.scope=s}}const Re={basic:u.BASIC,bas:u.BASIC,markdown:u.DISK_MARKDOWN,md:u.DISK_MARKDOWN,image:u.IMAGE,img:u.IMAGE};function Fe(r,e=u.NOTE_BLANK){const t=Re,s=Z(r).toLowerCase();return t[s]||e}class Ne extends w{}class g{constructor(e,{type:t,symbol:s=u.NOTE_BLANK}={type:"Unknown",symbol:u.NOTE_BLANK}){o(this,"type");o(this,"events");o(this,"_locked",!1);o(this,"parent");o(this,"createdDate");o(this,"editedDate");o(this,"id");o(this,"_name","");o(this,"meta");o(this,"_data");o(this,"_action");const{locked:a=!1,id:i,name:n=void 0,meta:c=void 0,data:m=void 0,action:h,createdDate:v=Date.now(),editedDate:y=void 0}=e;this.events=re(new se),this.createdDate=v||Date.now(),this.editedDate=y||v,this._locked=a||!1,this.id=i,this._name=n||"",this.type=t||"Unknown",this.meta=new Map([[E.SYMBOL,Fe(i||"",s||u.NOTE_BLANK)],[E.VISIBLE,!0],...c||[]]);let M=m;if(typeof m=="string")try{M=JSON.parse(m)}catch(F){throw console.log(M),F}this._action=h,this._data=be(M||{})}async remove(e={}){var i,n;const{silent:t}=Object.assign({silent:!1},e);let s;const a=this.isLocked();if(!a)s={type:this.type,id:this.id,name:this.name,path:await this.getPath(),size:this.size,storage:A(this)};else if(!t)throw new Error((i=d.get("FileSystemItem_itemLocked",await this.getPath()))==null?void 0:i.join(" "));return(t||!a)&&(this.events.next(new w({name:"remove",value:{item:this}})),this.events.unsubscribe(),(n=this.parent)==null||n.removeItem(this)),s?[s]:[]}isLocked(e=!1){return e?!1:this.parent&&this.parent.locked&&this.parent.id!==W?!0:this._locked}async copy(){const e=this.constructor,t=await this.export({encodeData:!1}),s=new e(t);return Promise.resolve(s)}rename(e,t={}){const{name:s=!1,ignore:a=!1}=Object.assign({name:!1,ignore:!1},t);if(!this.isLocked(a)){if(s)return this.name=e,this;{const i=this.id;this.id=xe(e||""),this.parent&&i!==this.id&&this.parent.changeItemId(this,i,this.id)}this.events.next(new Ne({name:"rename",value:{item:this}}))}return this}save(){this.events.next(new w({name:"save",value:{item:this}}))}getUsedMemory(){return this.size/this.maxSize}async export(e={}){const{encodeData:t}=Object.assign({encodeData:!0},e),s=new Map(this.meta);Array.from(s.keys()).forEach(i=>{s.get(i)instanceof le&&s.set(i,s.get(i).toJSON())});let a;return t&&typeof this._data=="string"?a=await Se(this._data):a=this._data,{type:this.type,id:this.id,name:this._name,createdDate:this.createdDate,editedDate:this.editedDate,data:a,meta:Array.from(s)}}get data(){let e=this._data;if(typeof this._data=="string")try{e=JSON.parse(this._data)}catch(t){console.error(t),e={type:"markdown",content:"Cannot parse data"}}return e}set data(e){typeof e=="object"&&(e=JSON.stringify(e)),this._data=e}get action(){return this._action}setId(e){this.id=e}setParent(e){this.parent=e}get locked(){var e;return((e=this.parent)==null?void 0:e.locked)||this._locked}get name(){return this._name||this.id}set name(e){this._name=e||""}get extension(){return Z(this.id)}get size(){const e=Object.values(this.data||{});return new Blob(e).size}get maxSize(){return new Blob(Object.values(this.data||{})).size}getRealMaxSize(){return new Blob(Object.values(this.data||{})).size}getBase(){return g.getBaseRecursive({item:this},!1)}getPath(){return g.getBaseRecursive({item:this})}static getBaseRecursive({item:e,path:t=[]},s=!0){if(s&&t.push(e.id),e.parent)return g.getBaseRecursive({item:e.parent,path:t});if(t=t.reverse(),t[0]===W&&t.shift(),t.length>0){let a=t[0];return/\./.test(a)||(a+=":"),`${a}${t.slice(1,t.length).join(De)}`}else return W}}d.add([["FileSystemItem_itemLocked",["Item Locked","Item is locked, can't be edit… %1"]]]);function be(r){return typeof r=="object"&&(r=JSON.stringify(r)),r}class f extends g{constructor(t,s){t={...t};super(t,s);o(this,"items",new Map);o(this,"_maxSize",Oe(1));this.addItems(t.items||this.items),this._maxSize=t.maxSize||this._maxSize}async export(t={}){const s={...await super.export(t),items:[]};return Reflect.deleteProperty(s,"data"),s.items=await Promise.all(Array.from(this.items.values()).map(a=>a.export())),s}async addItems(t,s=!1){let a=[];t instanceof Map?a=Array.from(t.values()):Array.isArray(t)&&(a=t),a=a.map(n=>(typeof n.data=="string"&&(n.data=pe(n.data)),n));const i=this.parseItems(a);return Promise.all(i.map(n=>this.addItem(n,s)))}static normalizeItemData(t){const s={...t},a=[];if("items"in t&&!(t.items instanceof Map)&&(s.items=new Map(t.items.map(i=>[i.id,i]))),"info"in t&&t.info)debugger;return"extension"in s&&(s.id+="."+s.extension,delete s.extension,a.push("extension")),"createTime"in s&&(s.createdDate=s.createTime,delete s.createTime,a.push("createTime")),"editTime"in s&&(s.editedDate=s.editTime,delete s.editTime,a.push("editTime")),"icon"in s&&(delete s.icon,a.push("icon")),a.length&&console.warn("@deprecated TODO: muss weg, hier werden die alten Items angepasst.",s,a),s}parseItems(t){return t.map(s=>{const a=f.normalizeItemData(s);let i;return a.type?i=H(a.type):"items"in a?i=H("Directory"):i=H(),new i(a)})}async addItem(t,s=!1){const a=t.parent;if(!s&&this.hasItem(t.id))throw new Error(`File ${t.id} exists`);if(a&&await a.removeItem(t),s){const i=Z(t.id),n=V(t.id);t.setId(X(ie(n,this,i),i))}return this.items.set(t.id,t),t.setParent(this),t.events.next(new w({name:"move",value:{item:t,lastParent:a}})),this.events.next(new w({name:"addItem",value:{item:t}})),t}removeItem(t){return t.setParent(void 0),this.items.delete(t.id),this.events.next(new w({name:"removeItem",value:{item:t}})),Promise.resolve()}async remove(t={}){var i;const{recursive:s}={recursive:!1,...t},a=[];if(s){const n=await this.getItems();for(const c of n.values())a.push(...await c.remove(t));return a.push(...await super.remove(t)),a}else{if((await this.getItems()).size>0)throw new Error((i=d.get("FileSystemItem_itemContainerNotEmpty",await this.getPath()))==null?void 0:i.join(" "));return await super.remove(t)}}changeItemId(t,s,a){this.items.delete(s),this.items.set(a,t),this.parent&&console.log("changeItemId by parent",s,a,this.parent.items)}getItems(){return Promise.resolve(this.items)}getItem(t){return this.items.get(t)}hasItem(t){return this.items.has(t)}get size(){return Array.from(this.items.values()).reduce(function(t,s){return s instanceof f||(t+=s.size),t},0)}get maxSize(){return t(this);function t(s){return s.parent&&s.getRealMaxSize()?t(s.parent):s.getRealMaxSize()}}}d.add([["FileSystemItem_itemContainerNotEmpty",["ItemWrapp Not Empty","ItemContainer not empty… %1"]]]);class P extends f{constructor(t,s){t={...t,locked:!0};super(t,s);o(this,"storage");this.storage=t.storage}get locked(){return this.storage.locked}mount(...t){return this.storage.mount(...t)}unmount(...t){return this.storage.unmount(...t)}async save(){return this.storage.save(await this.export())}}o(P,"TYPE","Storage");const j=class j extends P{constructor(e){super(e,{type:j.TYPE,symbol:u.CLOUD_DISK})}isLogged(e=!1){var t;return e||((t=this.storage.storage)==null?void 0:t.isLogged())||!1}isLocked(e){return this.isLogged(e)&&super.isLocked(e)}};o(j,"TYPE","CloudDisk");let R=j;class C extends f{constructor(e){super(e,{type:"Directory",symbol:u.DIRECTORY}),[E.WINDOW_SCALE,E.WINDOW_SCROLL_X,E.WINDOW_SCROLL_Y].forEach(t=>{this.meta.has(t)||this.meta.set(t,!0)})}}o(C,"TYPE","Directory");class k extends g{constructor(e){super(e,{type:"File"})}}o(k,"TYPE","File");class $ extends f{constructor(e){super(e,{type:"FloppyDisk"})}}o($,"TYPE","FloppyDisk");class K extends P{constructor(e){super(e,{type:"HardDisk",symbol:u.HARD_DISK})}}o(K,"TYPE","HardDisk");class B extends g{constructor(t){t={refPath:void 0,...t};super(t);o(this,"refPath");this.refPath=t.refPath}}o(B,"TYPE","Link");class z extends P{constructor(e){super(e,{type:"RamDisk",symbol:u.RAM_DISK})}}o(z,"TYPE","RamDisk");class ne extends f{constructor(e){e={...e,locked:!0,id:"ROOT",name:"ROOT"},super(e,{type:"Root"})}}o(ne,"TYPE","Root");class Y extends P{constructor(e){super(e,{type:"TmpDisk",symbol:u.TMP_DISK}),this.meta.set(E.VISIBLE,!1),this.meta.set(E.IGNORE_SYMBOL_REARRANGE,!0)}}o(Y,"TYPE","TmpDisk");class _ extends f{constructor(e){super(e,{type:"Trashcan",symbol:u.TRASHCAN})}}o(_,"TYPE","Trashcan");const l=class l{constructor(e){o(this,"name");o(this,"root");o(this,"currentItem");o(this,"storages",new Map);o(this,"events",re(new se));this.name=e,this.root=new ne,this.setup()}setup(){this.currentItem=this.root;const e=[this.addStorage(l.RAM_DISK_TITLE,S.SESSION,{id:l.RAM_DISK_NAME}),this.addStorage(l.HARD_DISK_NAME,S.LOCAL,{trashcan:!0}),this.addStorage(l.TMP_DISK_TITLE,S.TEMP,{id:l.TMP_DISK_NAME,trashcan:!1})];return Promise.all(e).catch(t=>{throw t})}createTmpFile(e,t,s,a){return this.createRootFile(`TMP:${e}`,t,s,a)}createRootDir(e,t,s){const a=`${e}`;return this.makedir(a,t,{override:!0,...s})}createRootFile(e,t,s,a){let i=t,n=s;typeof t=="object"&&(n=t,i=void 0);const c=`${e||"Unknown"}`;return this.makeFile(c,i,n,{...a||{},override:!0})}async get(e,t=!1){if(e instanceof g)return e;if(N(e))try{return await this.parsePath(e)}catch(s){if(t)return new g({id:p(e),name:p(e)});throw s}else throw d.get("FileSystem_pathInvalid",p(e),x(e))}async parsePath(e){var i,n;let t=e,s=this.currentItem;const a=e.match(/^([^:\\/]+):(.*)$/);if(a?(s=(i=this.root)==null?void 0:i.getItem(a[1]),t=a[2]):t[0]==="/"&&this.currentItem?(t=t.slice(1),s=A(this.currentItem)):t==="ROOT"?(s=this.root,t=""):t&&!t.includes("/")&&!/^\.+$/.test(t.trim())&&(s=this.root.getItem(t),t=""),t&&t.length>0&&(s=G(t.split("/"),s)),s)return s;throw d.get("FileSystem_pathInvalid",e,await((n=this.currentItem)==null?void 0:n.getBase())||"")}async addFloppyDisk(e){let t;if(typeof e=="function"?(t=await e(),t instanceof Promise&&(t=await t)):t=e,Array.isArray(t))throw new Error('data is an Array, use "defineFloppyDisk" for define a Disk');return this.addStorage(t)}async removeFloppyDisk(e){await e.remove({silent:!0})}async addStorage(e,t,s={}){s=Object.assign({id:null},s);let a;typeof t=="function"&&(a=t,t=S.CLOUD);const i=this.getFreeSlot(l.PREFIX.FLOPPY_DISK),n={id:i,itemClass:$,items:new Map};let c={};if(typeof e=="object"){const m=e;n.name=m.name||m.id,m.items&&(n.items=m.items),n.meta=Array.from(new Map([[E.SYMBOL,u.DISK_1],...m.meta||[]]))}else{switch(t){case S.SESSION:n.id=l.PREFIX.RAM,n.itemClass=z;break;case S.TEMP:n.id=l.PREFIX.TMP,n.itemClass=Y;break;case S.LOCAL:n.id=this.getFreeSlot(l.PREFIX.HARD_DISK),n.itemClass=K;break;case S.CLOUD:n.id=this.getFreeSlot(l.PREFIX.CLOUD_DISK),n.itemClass=R;break}n.id=s.id||n.id;let m;a&&typeof a=="function"?m=await this.registerStorageByStorage(n.id,a).mount(s):m=await this.registerStorageByType(n.id,t).mount(s);const h=await m.load();c=f.normalizeItemData(h),n.storage=m,S.NONE!==t&&(n.name=c.name||c.id||e)}return(n.meta=n.meta||[]).push(...c.meta||[]),this.addDisk({...n,...c,storage:n.storage||new J({id:i,name:l.TMP_DISK_TITLE})},s)}removeStorage(e){return e.unmount().then(()=>(this.events.next(new w({name:"removeStorage",value:{itemStorage:e}})),e))}registerStorageByType(e,t){const s=Ie(t),a=`${this.name}_${e}`,i=new s({id:e,name:a});return this.storages.set(a,i),i}registerStorageByStorage(e,t){const s=`${this.name}_${e}`,a=new t({id:e,name:s});return this.storages.set(s,a),a}connect(e,t){return this.addStorage(Ee,e,t).then(s=>s).catch(s=>{throw s})}async disconnect(e){return e=await this.removeStorage(e),e.remove({silent:!0,recursive:!0}),e}addDisk({id:e,name:t,meta:s,items:a,itemClass:i,storage:n},c){var v;c={trashcan:!1,...c},a instanceof Map&&c.trashcan&&(!a||a&&!a.has(_.TYPE))&&(a=a||new Map,a.set(_.TYPE,{type:_.TYPE,id:_.TYPE,name:_.TYPE}));const m=i;if(!m)throw new Error("ItemClass is empty!");const h=new m({id:e,name:t||e,meta:s,items:a,storage:n});return(v=this.root)==null||v.addItem(h),this.events.next(new w({name:"addDisk",value:{id:e,item:h}})),h}getFreeSlot(e){var s;let t=0;for(;(s=this.root)!=null&&s.hasItem(`${e}${t}`);)t++;return`${e}${t}`}async exist(e){try{return!!await this.get(e)}catch(t){return console.error(t),!1}}async changeDirectory(e){const t=await this.get(e);return this.currentItem=t,this.events.next(new w({name:"changeDirectory",value:t})),t}async makedir(e,t,s){const{override:a,meta:i}={override:!1,meta:[],...s};let n;e&&Ae(e)&&e!==t?n=await this.get(x(e)):n=this.currentItem;const c=new C({id:p(e),name:t||"",createdDate:Date.now(),meta:i});if(await D(n),a||!n.getItem(c.id))n.addItem(c,a),this.events.next(new w({name:"writeItem",value:c}));else throw d.get("FileSystem_fileExist",c.id);return await I(n),c}async makeFile(e,t,s,a){var M,F,q;const{override:i,meta:n}={...a,meta:a.meta||[]},c=p(e),m=new k({id:c,name:t||c,data:s,meta:n,createdDate:Date.now()});if(!N(e))throw d.get("FileSystem_invalidPath",e);let h=Te(e);const v=Me(e);h===v&&(h=".");let y;if(_e(h)?y=await this.get(h):((M=this.currentItem)==null?void 0:M.id)!=="ROOT"?y=await this.get(Pe(await((F=this.currentItem)==null?void 0:F.getPath())||"",h)):y=await this.get(h),y.hasItem(v))if(i)await((q=y.getItem(v))==null?void 0:q.remove()),y.addItem(m);else throw d.get("FileSystem_fileExist",m.id);else y.addItem(m),this.events.next(new w({name:"writeItem",value:m}));return await I(y),m}async editFile(e,t){const s=await this.get(e);return await D(s),await ke(s),s.data=t,I(s)}async editFileMeta(e,t,s){const a=await this.get(e);return Array.isArray(t)?t.map(i=>({name:i[0],value:i[1]})):a.meta.set(t,s),I(a)}async cleanFileMeta(e,{force:t}={}){const s=await this.get(e);return await D(s),s.meta=t?new Map:new Map(Array.from(s.meta.entries()).filter(([,a])=>a!==void 0)),I(s)}async getItemMetaList(e){const t=await this.get(e);return Array.from(t.meta).map(s=>({name:s[0],value:s[1]}))}async saveItem(e){const t=await this.get(e);return I(t)}async makelink(e,t=null){const s=await this.get(e);await D(s);const a=this.currentItem,i=new B({id:V(s.id)+".ref",name:`${t||s.name}`,createdDate:Date.now(),meta:[[E.REFERENCE,await s.getPath()]]});return await a.addItem(i),await I(s),i}async editlink(e,t){const s=await this.get(e);await D(s);const a=await this.get(t);return s.refPath=await a.getPath(),I(s)}async rename(e,t,{name:s,removeName:a}={name:!1,removeName:!1}){let i;if(e instanceof g)i=e;else if(N(e)||typeof e=="string")i=await this.get(e);else throw d.get("FileSystem_pathInvalid",x(e),e);return await D(i),a&&(s=!0,t=void 0),await i.rename(t,{ignore:!0,name:s}),I(i)}async copy(e,t,s={ignore:!1}){const{ignore:a}={ignore:!1,...s};let i,n,c;if(e instanceof g?(n=e,i=e.id):(n=await this.get(e),i=p(e)),t instanceof g)t instanceof f||(t=t.parent),c=t;else if(t){i=p(t);const h=await this.get(t,!0);if(h.parent?c=h.parent:c=await this.get(x(t)),!(c instanceof f))throw new Error("no ItemContainer")}else throw new Error('"to" is empty!');await D(n);const m=await n.copy();if(c instanceof f&&(a||!c.getItem(i)))m.rename(i),c.addItem(m,a),this.events.next(new w({name:"copyItem",value:m}));else throw d.get("FileSystem_fileExist",i);return I(m)}async move(e,t,{override:s}={}){let a,i,n;if(e instanceof g)i=e,a=e.id;else{if(i=await this.get(e),i instanceof P)throw d.get("FileSystem_cantMoveStorage",i.id);a=p(e)}if(t instanceof g)t instanceof f?n=t:n=t.parent;else{if(a=p(t),n=await this.get(t),n instanceof f)a=p(e);else return this.get(x(t));if(!(n instanceof f))throw new Error("no ItemContainer")}let c;if(await D(i),s||!await n.getItem(a))c=A(i),await i.rename(a),await n.addItem(i,s),this.events.next(new w({name:"moveItem",value:i}));else throw d.get("FileSystem_fileExist",i.id,a);return await I(i),c?c.save().then(()=>i):i}async remove(e,t,s={ignore:!1}){var n;const{ignore:a}={ignore:!1,...s},i=await this.get(e);await D(i);try{const c=await Le(t,i);return c[c.length-1].storage&&await((n=c[c.length-1].storage)==null?void 0:n.save()),c}catch(c){if(!a)throw c}}};o(l,"PREFIX",{FLOPPY_DISK:"DF",TMP:"TMP",RAM:"RAM",HARD_DISK:"HD",CLOUD_DISK:"CD"}),o(l,"TMP_DISK_NAME","TMP"),o(l,"TMP_DISK_TITLE","TMP DISK"),o(l,"RAM_DISK_NAME","RAM"),o(l,"RAM_DISK_TITLE","RAM DISK"),o(l,"HARD_DISK_NAME","HARD DISK");let te=l;function G(r,e){const t=r.shift();if(t===void 0)return e;if(t===".."){if(e.parent)return e.parent}else if(t==="."||t==="")return G(r,e);if(e){const s=e.getItem(t);return r.length>0&&s instanceof f?G(r,s):s}}function H(r){switch(r){case C.TYPE:return C;case _.TYPE:return _;case P.TYPE:return P;case Y.TYPE:return Y;case z.TYPE:return z;case K.TYPE:return K;case $.TYPE:return $;case R.TYPE:return R;case B.TYPE:return B;case k.TYPE:return k}return k}d.add([["FileSystem_invalidPath",["Invalid File",'Invalid path "%1"']],["FileSystem_invalidFile",["Invalid File",'Invalid file… "%1"']],["FileSystem_fileExist",["File Ready",'File already exists… "%1"']],["FileSystem_pathInvalid",["Path Invalid",'Path invalid… "%1"; base: "%2"']],["FileSystem_itemInvalid",["Item Invalid",'Item id invalid… "%1" from "%2"']],["FileSystem_cantMoveStorage",["Can't Move",`Can't move BaseStorage "%1"`]],["FileSystem_permissionsNeeded",["Permissions needed","Permissions needed"]]]);export{we as C,C as D,w as E,te as F,P as I,ne as R,L as S,S as T,Z as a,He as b,_ as c,f as d,d as e,xe as f,Ie as g,p as h,Je as i,pe as j,X as k,k as l,Ue as m,Ye as n,g as o,Pe as p,Se as q,I as s,We as u,je as w};
